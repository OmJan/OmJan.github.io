<!DOCTYPE html>
<html prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="IT blog">
<meta name="viewport" content="width=device-width">
<title>VelikiiNehochuha Blog</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="rss.xml">
<link rel="canonical" href="http://velikiinehochuha.github.io/">
<link rel="next" href="index-2.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link rel="prefetch" href="posts/dinamicheskoe-programmirovanie/" type="text/html">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="http://velikiinehochuha.github.io/" title="VelikiiNehochuha Blog" rel="home">

        <span id="blog-title">VelikiiNehochuha Blog</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="archive.html">Архив</a></li>
                <li><a href="categories/">Тэги</a></li>
                <li><a href="rss.xml">RSS лента</a></li>

    
    
    
    </ul></nav></header><main id="content"><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/dinamicheskoe-programmirovanie/" class="u-url">Лекция 10-11, Динамическое программирование</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/dinamicheskoe-programmirovanie/" rel="bookmark">
            <time class="published dt-published" datetime="2020-06-20T17:29:57+03:00" itemprop="datePublished" title="2020-06-20 17:29">2020-06-20 17:29</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib_recusrion</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
	<span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">fib_recusrion</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib_recusrion</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fib_recusrion</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>

<p>
Очевидно что количество повторных вычислений неприемлимо велико
Экспотенциальный рост количества вычислений
</p>

<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fib_linier</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
	<span class="k">return</span> <span class="n">n</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="n">fib_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
	<span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fib_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fib_linier</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>

<p>
Так все линейно
</p>

<p>
Сколько различных траекторий допрыгать из 1 в N? Если можно прыгнуть на 1 и на 2 клетки.
</p>

<p>
Кn = Kn-1 + Kn-2
</p>

<p>
Количество уникальных перестановок траекторий в точке N равно количеству уникальных траекторий в N-1 + количество уникальных траекторий в N-2 (перестановок - траекторий)
</p>

<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trajectory_num</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
	<span class="k">return</span> <span class="n">n</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="n">trajectory_num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
	<span class="n">trajectory_num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">trajectory_num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">trajectory_num</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>

<p>
Запретим некоторые клетки для посещения и добавим еще один вариант переджвижения 3.
</p>

<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trajectory_num</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">allowed</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">allowed</span><span class="p">[</span><span class="mi">2</span><span class="p">])]:</span>
	<span class="k">return</span> <span class="n">n</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">3</span>
    <span class="n">trajectory_num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">allowed</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">allowed</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
	    <span class="n">trajectory_num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
	    <span class="n">trajectory_num_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">trajectory_num_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

<p>
<b>Минимальная стоимость посещение клетки N</b>
</p>

<p>
price[i] - за посещение клетки i
C[i] - минимально возможная стоимость достижения клетки i
пусть доступны шаги +1 и +2
Ci = price[i] + min(Ci-1, Ci-2)
</p>


<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_min_cost</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">price</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">'-inf'</span><span class="p">),</span> <span class="n">price</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">price</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
	<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">price</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">price</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">price</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">C</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

<p>
<b>Двумерное динамическое программирование.</b>
</p>

<p>
Шахматный король на доске MxN. Сколькими способами шахматный король может добраться до заданной клетки, если он может шагать только вправо и вниз.
</p>

<p>
Knm - количество способов достичь клетки (N,M)
</p>

<p>
Kij = K(i-1)j + Ki(j-1)
</p>

<p>
C из n по k - треугольник паскаля.
</p>


<p>
<b>Наибольшая общая последовательность</b>
</p>


<p>
A,B - массивы чисел len(A) <code>= N, len(B) =</code> M
Последовательность - С, содержит элементы А в исходном порядке, но возможно не все. При поиске важен порядок элементов! Если порядок не важен, нужно использовать другой алгоритм.
</p>

<p>
[] - последовательность - подпоследовательность любой последовательности А
</p>

<p>
Какая максимльная подпоследовательность у них общая.
Пусть Fij - длина наибольшей возможной подпоследовательности частей А и B.
Ai = A[0:i] - часть А содержащая первые i элементов
Bj = B[0:j] - часть B содержит первые j элементов
</p>

<p>
Fij
</p>


<p>
a1, a2, a3, a4, a5, .., ai
b1, b2,             .., bj
</p>

<p>
если ai = bj, то 1 + F(i-1)(j-1)
</p>

<p>
если ai != bj, то max(Fi(j-1), F(i-1)j)
</p>

<p>
F0j = 0
Fi0 = 0
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>
<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_common_sequence</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
	    <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	    <span class="k">else</span><span class="p">:</span>
		<span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">F</span>


<span class="k">def</span> <span class="nf">l_common_sequence</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">_common_sequence</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">find_common_sequence</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">_common_sequence</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>
	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
	    <span class="n">i_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
	    <span class="n">j_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
	    <span class="k">if</span> <span class="n">F</span><span class="p">[</span><span class="n">i_index</span><span class="p">][</span><span class="n">j_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">F</span><span class="p">[</span><span class="n">i_index</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j_index</span><span class="p">]</span> <span class="ow">and</span> <span class="n">F</span><span class="p">[</span><span class="n">i_index</span><span class="p">][</span><span class="n">j_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">F</span><span class="p">[</span><span class="n">i_index</span><span class="p">][</span><span class="n">j_index</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
		<span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i_index</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">find_common_sequence</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
</pre></div>


<p>
<b>Наибольшая возрастающая под последовательность</b>
</p>

<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gis</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
	<span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
	    <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
	<span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="nb">print</span><span class="p">(</span><span class="n">gis</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">]))</span>
</pre></div>

<p>
<b>Алгоритм укладки рюкзака</b>
</p>

<p>
Есть мешок и некоторый набор предметов. M - максимальный вес который можно унести. У каждого предмета есть цена и масса. Какую максимальную стоимость предметов вы можете унести. Полностью задача решается только полным перебором.
Но дискретный алгоритм укладки рюкзака решается методом динамического программирования.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"> </td>
<td class="org-right">цена</td>
<td class="org-right">масса</td>
</tr>
<tr>
<td class="org-left">гитара</td>
<td class="org-right">1500</td>
<td class="org-right">1</td>
</tr>
<tr>
<td class="org-left">магнитовон</td>
<td class="org-right">3000</td>
<td class="org-right">4</td>
</tr>
<tr>
<td class="org-left">ноутбук</td>
<td class="org-right">2000</td>
<td class="org-right">3</td>
</tr>
<tr>
<td class="org-left">телефон</td>
<td class="org-right">2000</td>
<td class="org-right">1</td>
</tr>
<tr>
<td class="org-left">телефон</td>
<td class="org-right">1000</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">предмет/емкость рюкзака</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
<tr>
<td class="org-left">гитара</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
</tr>
<tr>
<td class="org-left">магнитовон</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">3000</td>
</tr>
<tr>
<td class="org-left">ноутбук</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
</tr>
</tbody>
</table>
<p>
Стоимость ячейки можно вычислить таким образом
</p>

<p>
CELL[i][j] = выбираем максимум из
</p>
<ol class="org-ol">
<li>Предведущий максимум (значение в CELL[i-1][j])</li>
<li>Стоимость текущего элемента + CELL[i-1][j-вес текущего]</li>
</ol>
<p>
можно добавлять элементы динамически к уже существующим элементам, например добавив телефон стоимостью 2000
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">предмет/емкость рюкзака</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
<tr>
<td class="org-left">гитара</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
</tr>
<tr>
<td class="org-left">магнитовон</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">3000</td>
</tr>
<tr>
<td class="org-left">ноутбук</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
</tr>
<tr>
<td class="org-left">телефон</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
<td class="org-right">3500</td>
<td class="org-right">4000</td>
</tr>
</tbody>
</table>
<p>
Упражнение предположим добавили еще mp3 плеер, стоимостью 1000 и весом 1. Стоит ли брать его?
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">предмет/емкость рюкзака</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
<tr>
<td class="org-left">гитара</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
</tr>
<tr>
<td class="org-left">магнитовон</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">3000</td>
</tr>
<tr>
<td class="org-left">ноутбук</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
</tr>
<tr>
<td class="org-left">телефон</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
<td class="org-right">3500</td>
<td class="org-right">4000</td>
</tr>
<tr>
<td class="org-left">плеер</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
<td class="org-right">4500</td>
<td class="org-right">4500</td>
</tr>
</tbody>
</table>
<p>
Ответ: да. стоит сумма будет 4500.
</p>

<p>
Что произойдет при изменении порядка строк?
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">предмет/емкость рюкзака</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
<tr>
<td class="org-left">магнитовон</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">3000</td>
</tr>
<tr>
<td class="org-left">ноутбук</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">2000</td>
<td class="org-right">3000</td>
</tr>
<tr>
<td class="org-left">гитара</td>
<td class="org-right">1500</td>
<td class="org-right">1500</td>
<td class="org-right">2000</td>
<td class="org-right">3500</td>
</tr>
</tbody>
</table>
<p>
Видим что итоговый результат не изменился, хотя таблица заполнена иным образом.
</p>


<p>
Можно ли заполнять таблицу по столбцам а не по строкам?
</p>

<p>
Ответ: а данном случае вполне возможно.
</p>


<p>
<b>Оптимизация туристического маршрута</b>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-left">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">Достопримечательность</td>
<td class="org-left">Время</td>
<td class="org-right">Оценка</td>
</tr>
<tr>
<td class="org-left">Вестминстерское аббатство</td>
<td class="org-left">0.5 дня</td>
<td class="org-right">7</td>
</tr>
<tr>
<td class="org-left">Театр «Глобус»</td>
<td class="org-left">0.5 дня</td>
<td class="org-right">6</td>
</tr>
<tr>
<td class="org-left">Национальная галерея</td>
<td class="org-left">1 день</td>
<td class="org-right">9</td>
</tr>
<tr>
<td class="org-left">Британский музей</td>
<td class="org-left">2 дня</td>
<td class="org-right">9</td>
</tr>
<tr>
<td class="org-left">Собор св. Павла</td>
<td class="org-left">0.5 дня</td>
<td class="org-right">8</td>
</tr>
</tbody>
</table>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">предмет/емкость рюкзака</td>
<td class="org-right">0.5</td>
<td class="org-right">1</td>
<td class="org-right">1.5</td>
<td class="org-right">2</td>
</tr>
<tr>
<td class="org-left">Вестминстерское аббатство</td>
<td class="org-right">7</td>
<td class="org-right">7</td>
<td class="org-right">7</td>
<td class="org-right">7</td>
</tr>
<tr>
<td class="org-left">Театр «Глобус»</td>
<td class="org-right">7</td>
<td class="org-right">13</td>
<td class="org-right">13</td>
<td class="org-right">13</td>
</tr>
<tr>
<td class="org-left">Национальная галерея</td>
<td class="org-right">7</td>
<td class="org-right">13</td>
<td class="org-right">16</td>
<td class="org-right">22</td>
</tr>
<tr>
<td class="org-left">Британский музей</td>
<td class="org-right">7</td>
<td class="org-right">13</td>
<td class="org-right">16</td>
<td class="org-right">22</td>
</tr>
<tr>
<td class="org-left">Собор св. Павла</td>
<td class="org-right">8</td>
<td class="org-right">15</td>
<td class="org-right">21</td>
<td class="org-right">24</td>
</tr>
</tbody>
</table>
<p>
<b>Наибольшая общая последовательность</b>
</p>

<p>
если ai = bj, то 1 + F(i-1)(j-1)
</p>

<p>
если ai != bj, то max(Fi(j-1), F(i-1)j)
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right">
<col class="org-right">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left"> </td>
<td class="org-right">f</td>
<td class="org-right">o</td>
<td class="org-right">s</td>
<td class="org-right">h</td>
</tr>
<tr>
<td class="org-left">f</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
<tr>
<td class="org-left">i</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
<tr>
<td class="org-left">s</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>
<tr>
<td class="org-left">h</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/potoki/" class="u-url">SICP Потоки</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/potoki/" rel="bookmark">
            <time class="published dt-published" datetime="2020-06-12T19:17:51+03:00" itemprop="datePublished" title="2020-06-12 19:17">2020-06-12 19:17</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-org39c0b2d" class="outline-2">
<h2 id="org39c0b2d">Упражнение 3.50</h2>
<div class="outline-text-2" id="text-org39c0b2d">
<p>
Закончите следующее определение, которое обращает процедуру stream-map, чтобы она позволяла использовать процедуры от нескольких аргументов, подобно map из раздела 2.2.1
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">stream-map</span> <span class="nv">proc</span> <span class="o">.</span> <span class="nv">argstreams</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">stream-null?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">argstreams</span><span class="p">))</span>
      <span class="nv">the-empty-stream</span>
      <span class="p">(</span><span class="nf">cons-stream</span>
       <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">stream-car</span> <span class="nv">argstreams</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">apply </span><span class="nv">stream-map</span>
	      <span class="p">(</span><span class="nb">cons </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">stream-cdr</span> <span class="nv">argstreams</span><span class="p">))))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgd4d14d3" class="outline-2">
<h2 id="orgd4d14d3">Упражнение 3.51</h2>
<div class="outline-text-2" id="text-orgd4d14d3">
<p>
Чтобы внимательнее изучить задержанные вычисления, мы воспользуемся следующей процедурой, которая печатает свой аргумент, а затем возвращает его:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">show</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">display-line</span> <span class="nv">x</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span>
</pre></div>

<p>
Что печатает интерпретатор в ответ на каждое выражение из следующей последовательности?
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nf">stream-map</span> <span class="nv">show</span> <span class="p">(</span><span class="nf">stream-enumerate-interval</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">)))</span>
<span class="c1">;; 0</span>
<span class="c1">;; 2</span>
<span class="c1">;; ...</span>
<span class="c1">;; 10</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;; 5</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="nv">x</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">;; 7</span>
</pre></div>
</div>
</div>

<div id="outline-container-org86ba445" class="outline-2">
<h2 id="org86ba445">Упражнение 3.52</h2>
<div class="outline-text-2" id="text-org86ba445">
<p>
Рассмотрим последовательность выражений
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">sum</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">accum</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">sum</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">sum</span><span class="p">))</span>
  <span class="nv">sum</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">seq</span> <span class="p">(</span><span class="nf">stream-map</span> <span class="nv">accum</span> <span class="p">(</span><span class="nf">stream-enumerate-interval</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">)))</span>
<span class="nv">seq</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nf">stream-filter</span> <span class="nv">even?</span> <span class="nv">seq</span><span class="p">))</span>
<span class="nv">y</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nf">stream-filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">remainder </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
			 <span class="nv">seq</span><span class="p">))</span>
<span class="nv">z</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="nv">y</span> <span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="nf">display-stream</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>

<p>
Изменился бы этот результат, если бы мы реализовали (delay выражение) просто как (lambda () выражение), не применяя оптимизацию через memo-proc? Объясните свой ответ.
</p>

<p>
Ответ бы не изменился, но при вызове display-stream элементы последовательности вычислялись бы повторно, что сказывается на производительности.
</p>
</div>
</div>

<div id="outline-container-org69f5df4" class="outline-2">
<h2 id="org69f5df4">Упражнение 3.53</h2>
<div class="outline-text-2" id="text-org69f5df4">
<p>
Не запуская программу, опишите элементы потока, порождаемого
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-streams</span> <span class="nv">s1</span> <span class="nv">s2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">stream-map</span> <span class="nv">+</span> <span class="nv">s1</span> <span class="nv">s2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">cons-stream</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">add-streams</span> <span class="nv">s</span> <span class="nv">s</span><span class="p">)))</span>
</pre></div>

<p>
1 2 4 8 16, …
</p>
</div>
</div>


<div id="outline-container-orgb037f6a" class="outline-2">
<h2 id="orgb037f6a">Упражнение 3.54</h2>
<div class="outline-text-2" id="text-orgb037f6a">
<p>
Определите процедуру mul-streams, аналогичную add-streams, которая порождает поэлементное произведение двух входных потоков. С помощью нее и потока integers закончите следующее определение потока, n-й элемент которого (начиная с 0) равен факториалу n + 1:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-streams</span> <span class="nv">s1</span> <span class="nv">s2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">stream-map</span> <span class="nv">*</span> <span class="nv">s1</span> <span class="nv">s2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">factorials</span> <span class="p">(</span><span class="nf">cons-stream</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">mul-streams</span> <span class="nv">integers</span> <span class="nv">factorials</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org3eb2a04" class="outline-2">
<h2 id="org3eb2a04">Упражнение 3.55.</h2>
<div class="outline-text-2" id="text-org3eb2a04">
<p>
Определите процедуру partial-sums, которая в качестве аргумента берет поток S, а возвращает поток, элементы которого равны S0, S0 + S1, S0 + S1 + S2, . . .. Например, (partial-sums integers) должно давать поток 1, 3, 6, 10, 15
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">stream</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter</span> <span class="nv">ps</span> <span class="nv">prev</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cons-stream</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">stream-car</span> <span class="nv">ps</span><span class="p">)</span> <span class="nv">prev</span><span class="p">)</span> <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nf">stream-cdr</span> <span class="nv">ps</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">stream-car</span> <span class="nv">ps</span><span class="p">)</span> <span class="nv">prev</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">stream</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">;; 1</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; 3</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; 6</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; 10</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; 15</span>

<span class="c1">;; more nicely solution</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">s</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">add-streams</span> <span class="nv">s</span> <span class="p">(</span><span class="nf">cons-stream</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">s</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">;; 1</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; 3</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; 6</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">;; 10</span>
<span class="p">(</span><span class="nf">stream-ref</span> <span class="p">(</span><span class="nf">partial-sums</span> <span class="nv">integers</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; 15</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6959d5e" class="outline-2">
<h2 id="org6959d5e">Упражнения 3.56.</h2>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-34-parallelizm-vremia-imeet-znachenie/" class="u-url">SICP 3.4 Параллелизм: время имеет значение</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-34-parallelizm-vremia-imeet-znachenie/" rel="bookmark">
            <time class="published dt-published" datetime="2020-02-14T14:23:44+03:00" itemprop="datePublished" title="2020-02-14 14:23">2020-02-14 14:23</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-org0f5b9a8" class="outline-2">
<h2 id="org0f5b9a8">Упражнение 3.38</h2>
<div class="outline-text-2" id="text-org0f5b9a8">
<p>
Пусть Петр, Павел и Мария имеют общий счет, на котором вначале лежит 100 долларов. Петр кладет на счет 10 долларов, одновременно с этим Павел берет 20, а Мария берет половину денег со счета. При этом они выполняют следующие операции:
</p>

<p>
Петр: (set! balance (+ balance 10))
Павел: (set! balance (- balance 20))
Мария: (set! balance (- balance (/ balance 2)))
</p>

<p>
а. Перечислите возможные значения balance после завершения операций, предполагая, что банковская система требует от транзакций исполняться последовательно в каком-то порядке.
</p>

<ol class="org-ol">
<li>Петр, Павел, Мария, в результате 45</li>
<li>Петр, Мария, Павел, в результате 35</li>
<li>Павел, Петр, Мария, в результате 45</li>
<li>Павел, Мария, Петр, в результате 50</li>
<li>Мария, Петр, Павел, в результате 40</li>
<li>Мария, Павел, Петр, в результате 40</li>
</ol>
<p>
б. Назовите какие-нибудь другие значения, которые могли бы получиться, если бы система разрешала операциям чередоваться. Нарисуйте временные диаграммы, подобные рис. 3.29, чтобы объяснить, как возникают такие результаты.
</p>

<p>
<img src="images/3.38.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-org4fa1839" class="outline-2">
<h2 id="org4fa1839">Упражнение 3.39</h2>
<div class="outline-text-2" id="text-org4fa1839">
<p>
Какие из пяти возможных исходов параллельного выполнения сохраняются, если мы сериализуем выполнение таким образом:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">))</span>

<span class="p">(</span><span class="nf">parallel-execute</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">((</span><span class="nf">s</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))))))</span>
		  <span class="p">(</span><span class="nf">s</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>

<p>
таким образом мы отсекаем варианты когда P1 получает разные значения для x.
</p>

<p>
101: 	P1 потом P2
121: 	P2 потом P1
11: 	P2 читает x, потом P1 выставляет x в 100, затем P2 выставляет x.
100: 	P1 считывает x (дважды), потом P2 ставит x to 11, потом P1 ставит x.
</p>

<p>
случай который не произойдет:
</p>

<p>
110:  P2 меняет x c 10 на 11 между двумя чтениями P1 значения x, во время выполнения (* x x)
</p>
</div>
</div>

<div id="outline-container-orgbc47be1" class="outline-2">
<h2 id="orgbc47be1">Упражнение 3.40</h2>
<div class="outline-text-2" id="text-orgbc47be1">
<p>
Укажите все возможные значения x при выполнении
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>

<span class="p">(</span><span class="nf">parallel-execute</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
		  <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>

<ol class="org-ol">
<li>P1 потом P2, 1 000 000</li>
<li>P2 потом P1, 1 000 000</li>
<li>P2 считал x = 10, потом P1, потом P2 выставил 10 * 100 * 100 = 100 000</li>
<li>P2 считал x = 10 (дважды), потом P1, потом P2 выставил 10 * 10 * 100 = 10 000</li>
<li>P2 считал x = 10 (трижды), потом P1, потом P2 выставил 1000</li>
<li>P1 считал x = 10, потом P2, потом 10 * 1000 = 10 000</li>
<li>P2 считал x = 10 (дважды), потом P2, потом P1 100</li>
</ol>
<p>
Какие из них сохраняются, если вместо этого мы выполняем   сериализованные процедуры:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">))</span>
<span class="p">(</span><span class="nf">parallel-execute</span> <span class="p">(</span><span class="nf">s</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))))</span>
		  <span class="p">(</span><span class="nf">s</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)))))</span>
</pre></div>

<p>
только 1 000 000
</p>
</div>
</div>

<div id="outline-container-orgcb12047" class="outline-2">
<h2 id="orgcb12047">Упражнение 3.41</h2>
<div class="outline-text-2" id="text-orgcb12047">
<p>
Бен Битобор считает, что лучше было бы реализовать банковский счет таким образом (измененная строка отмечена комментарием):
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	       <span class="nv">balance</span><span class="p">)</span>
	<span class="s">"Insufficient funds"</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>
  <span class="c1">;; continued on next page</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">protected</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="p">(</span><span class="nf">protected</span> <span class="nv">withdraw</span><span class="p">))</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="p">(</span><span class="nf">protected</span> <span class="nv">deposit</span><span class="p">))</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'balance</span><span class="p">)</span>
	     <span class="p">((</span><span class="nf">protected</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="nv">balance</span><span class="p">))))</span> <span class="c1">; serialized</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
			 <span class="nv">m</span><span class="p">))))</span>
    <span class="nv">dispatch</span><span class="p">))</span>
</pre></div>

<p>
поскольку несериализованный доступ к банковскому счету может привести к неправильному поведению. Вы согласны? Существует ли сценарий, который демонстрирует обоснованность беспокойства Бена?
</p>

<p>
нет, чтение можно не сериализовывать
</p>
</div>
</div>

<div id="outline-container-org98f924a" class="outline-2">
<h2 id="org98f924a">Упражнение 3.42</h2>
<div class="outline-text-2" id="text-org98f924a">
<p>
Бен Битобор говорит, что слишком расточительно в ответ на каждое сообщение withdraw и deposit создавать по новой сериализованной процедуре. Он говорит, что можно изменить make-account так, чтобы все вызовы protected происходили вне процедуры dispatch. Таким обра-
зом, счет будет возвращать одну и ту же сериализованную процедуру (созданную тогда же, когда и сам счет) каждый раз, когда у него просят процедуру снятия денег:
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	       <span class="nv">balance</span><span class="p">)</span>
	<span class="s">"Insufficient funds"</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">protected</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">protected-withdraw</span> <span class="p">(</span><span class="nf">protected</span> <span class="nv">withdraw</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">protected-deposit</span> <span class="p">(</span><span class="nf">protected</span> <span class="nv">deposit</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
	<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">protected-withdraw</span><span class="p">)</span>
	      <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">protected-deposit</span><span class="p">)</span>
	      <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'balance</span><span class="p">)</span> <span class="nv">balance</span><span class="p">)</span>
	      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
			   <span class="nv">m</span><span class="p">))))</span>
      <span class="nv">dispatch</span><span class="p">)))</span>
</pre></div>

<p>
Безопасно ли такое изменение? В частности, есть ли разница в том, в каком порядке может происходить параллельное выполнение в этих двух версиях make-account?
</p>

<p>
преобразование эквивалентно тому что мы выполняли ранее, поэтому такую замену можно использовать
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">))</span>
<span class="p">(</span><span class="nf">parallel-execute</span> <span class="p">(</span><span class="nf">s</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))))</span>
		  <span class="p">(</span><span class="nf">s</span> <span class="p">(</span><span class="k">lambda </span><span class="p">()</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org763296d" class="outline-2">
<h2 id="org763296d">Упражнение 3.43</h2>
<div class="outline-text-2" id="text-org763296d">
<p>
Предположим, что значения баланса на трех счетах вначале равны 10, 20 и 30 долларам, и что несколько процессов занимаются обменом значений баланса. Покажите, что если эти процессы выполняются последовательно, то после любого количества обменов значения баланса по-прежнему
будут равны 10, 20 и 30 долларам, в каком-то порядке. Нарисуйте временную диаграмму вроде той, которая изображена на рис. 3.29, и покажите, что указанное условие может нарушаться, если работает первая версия процедуры обмена из этого раздела. Покажите, с другой стороны, что даже с первой программой exchange общая сумма балансов на счетах сохранится. Нарисуйте временную диаграмму, показывающую, что если бы мы не сериализовали транзакции по отдельным счетам, это условие тоже могло бы нарушаться.
</p>


<p>
При последовательном обмене очевидно что значения балансов останутся прежними без учета порядка.
</p>

<p>
Первая версия процедуры, когда сериализатор частный для каждого аккаунта
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exchange</span> <span class="nv">account1</span> <span class="nv">account2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">difference</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">account1</span> <span class="ss">'balance</span><span class="p">)</span>
		       <span class="p">(</span><span class="nf">account2</span> <span class="ss">'balance</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">account1</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">difference</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">account2</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">difference</span><span class="p">)))</span>
</pre></div>

<p>
P1 считываем баланс A1 A2, вычисляет разницу
</p>

<p>
после этого P2 считывает A2 A3 вычисляет разницу и выполняет смену счетов 2 3. На втором 30 на третьем 20.
После этого P1 делает списание -10 c первого и делает deposit -10 на второй. В итоге получается
</p>

<p>
20 20 20.
</p>

<p>
<img src="images/3.43.png" alt="nil"></p>

<p>
Сумма остается прежней, но происходит не очевидное перераспределение сумм между аккаунтами.
</p>


<p>
Если бы счета вообще не сериализовались, то общая сумма могла бы измениться, например
</p>

<p>
P1 считывает баланс A1 A2, вычисляет разницу - 10
P2 считывает баланс A2 A3, вычисляет разницу - 10
</p>

<p>
P1 делает списание -10 на A1
</p>

<p>
P1 и P2 считывают баланс A2 20 и одновременно делают операции deposit -10 и withdraw -10, получается что на счете A2 образуется сумма 30
</p>

<p>
P2 делает депозит -10 на A2
</p>

<p>
в итоге получается набор сумм 20 30 30.
20 30 30.
</p>

<p>
<img src="images/3.43_2.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-orgdde64cb" class="outline-2">
<h2 id="orgdde64cb">Упражнение 3.44</h2>
<div class="outline-text-2" id="text-orgdde64cb">
<p>
Рассмотрим задачу переноса денег с одного счета на другой. Бен Битобор утверждает, что ее можно решить с помощью следующей процедуры, даже в тех случаях, когда много людей одновременно перемещают деньги между различными счетами, если использовать при этом какой-то механизм,
сериализующий операции занесения на счет и снятия со счета, например, версию make-account из нашего текста.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">transfer</span> <span class="nv">from-account</span> <span class="nv">to-account</span> <span class="nv">amount</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">from-account</span> <span class="err">’</span><span class="nv">withdraw</span><span class="p">)</span> <span class="nv">amount</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">to-account</span> <span class="err">’</span><span class="nv">deposit</span><span class="p">)</span> <span class="nv">amount</span><span class="p">))</span>
</pre></div>

<p>
Хьюго Дум считает, что с этой версией возникнут проблемы и что нужно использовать более сложный подход, вроде того, который требуется при решении задачи обмена. Прав ли он? Если нет, то в чем состоит существенная разница между задачей перевода денег и задачей обмена
счетов? (Нужно предположить, что значение баланса на from-account по крайней мере равно amount.)
</p>

<p>
Такая процедура вполне корректна. Разница между обменом состоит в том что там нам было необходимо поменять местами счета, что при одновременном выполнении могло привести к не очевидному перераспределению, тут же нет такого требования, важно что бы итоговая сумма не изменилась, а это требование выполняется.
</p>
</div>
</div>


<div id="outline-container-org219e59c" class="outline-2">
<h2 id="org219e59c">Упражнение 3.45</h2>
<div class="outline-text-2" id="text-org219e59c">
<p>
Хьюго Дум полагает, что теперь, когда операции снятия денег со счета и занесения их на счет перестали сериализовываться автоматически, система банковских счетов стала неоправданно сложной и работать с ней правильным образом чересчур трудно. Он предлагает сделать так, чтобы make-account-and-serializer экспортировал сериализатор (для использования в процедурах вроде serialized-exchange), и вдобавок сам использовал его для сериализации простых операций
со счетом, как это делал make-account. Он предлагает переопределить объект-счет так:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account-and-serializer</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	       <span class="nv">balance</span><span class="p">)</span>
	<span class="s">"Insufficient funds"</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">balance-serializer</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="p">(</span><span class="nf">balance-serializer</span> <span class="nv">withdraw</span><span class="p">))</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="p">(</span><span class="nf">balance-serializer</span> <span class="nv">deposit</span><span class="p">))</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'balance</span><span class="p">)</span> <span class="nv">balance</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'serializer</span><span class="p">)</span> <span class="nv">balance-serializer</span><span class="p">)</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
			 <span class="nv">m</span><span class="p">))))</span>
    <span class="nv">dispatch</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">account</span> <span class="nv">amount</span><span class="p">)</span>
 <span class="p">((</span><span class="nf">account</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">amount</span><span class="p">))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exchange</span> <span class="nv">account1</span> <span class="nv">account2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">difference</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">account1</span> <span class="ss">'balance</span><span class="p">)</span>
		       <span class="p">(</span><span class="nf">account2</span> <span class="ss">'balance</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">account1</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">difference</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">account2</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">difference</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">serialized-exchange</span> <span class="nv">account1</span> <span class="nv">account2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">serializer1</span> <span class="p">(</span><span class="nf">account1</span> <span class="ss">'serializer</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">serializer2</span> <span class="p">(</span><span class="nf">account2</span> <span class="ss">'serializer</span><span class="p">)))</span>
    <span class="p">((</span><span class="nf">serializer1</span> <span class="p">(</span><span class="nf">serializer2</span> <span class="nv">exchange</span><span class="p">))</span>
     <span class="nv">account1</span>
     <span class="nv">account2</span><span class="p">)))</span>
</pre></div>

<p>
Объясните, в чем Хьюго ошибается. В частности, рассмотрите, что происходит при вызове serialized-exchange.
</p>

<p>
получится троекратный вызов serializer на withdraw и deposit. Объект будучи заблокированным для изменения снова будет ожидать получение разрешения на изменение, в итоге он никогда не дождется разрешения.
</p>
</div>
</div>


<div id="outline-container-org755f61c" class="outline-2">
<h2 id="org755f61c">Упражнение 3.46</h2>
<div class="outline-text-2" id="text-org755f61c">
<p>
Допустим, что мы реализуем test-and-set в виде обыкновенной процедуры, как показано в тексте, не пытаясь сделать ее атомарной. Нарисуйте временную диаграмму, подобную диаграмме на рис. 3.29, и покажите, как реализация мьютекса может ошибиться и позволить двум процессам одновременно захватить мьютекс.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-serializer</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mutex</span> <span class="p">(</span><span class="nf">make-mutex</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">serialized-p</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">mutex</span> <span class="ss">'acquire</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">val</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">p</span> <span class="nv">args</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nf">mutex</span> <span class="ss">'release</span><span class="p">)</span>
	  <span class="nv">val</span><span class="p">))</span>
      <span class="nv">serialized-p</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-mutex</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">cell</span> <span class="p">(</span><span class="nb">list </span><span class="nv">false</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">the-mutex</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'acquire</span><span class="p">)</span>
	     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">test-and-set!</span> <span class="nv">cell</span><span class="p">)</span>
		 <span class="p">(</span><span class="nf">the-mutex</span> <span class="ss">'acquire</span><span class="p">)))</span> <span class="c1">; retry</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'release</span><span class="p">)</span> <span class="p">(</span><span class="nf">clear!</span> <span class="nv">cell</span><span class="p">))))</span>
    <span class="nv">the-mutex</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">clear!</span> <span class="nv">cell</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">set-car! </span><span class="nv">cell</span> <span class="nv">false</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">test-and-set!</span> <span class="nv">cell</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">car </span><span class="nv">cell</span><span class="p">)</span>
      <span class="nv">true</span>
      <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nb">set-car! </span><span class="nv">cell</span> <span class="nv">true</span><span class="p">)</span>
	     <span class="nv">false</span><span class="p">)))</span>
</pre></div>

<p>
если мы не гарантируем атомарность проверки проверки test-and-set! то можем получить ошибку когда у нас мьютекс будет захвачен сразу двумя процессами, это ситуация ничем не отличается от той, когда мы вообще не использовали сериализатор, у нас может произойти одновременное назначение разных балансов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">test-and-set!</span> <span class="nv">cell</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">without-interrupts</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">car </span><span class="nv">cell</span><span class="p">)</span>
	 <span class="nv">true</span>
	 <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nb">set-car! </span><span class="nv">cell</span> <span class="nv">true</span><span class="p">)</span>
		<span class="nv">false</span><span class="p">)))))</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgf765f97" class="outline-2">
<h2 id="orgf765f97">Упражнение 3.47</h2>
<div class="outline-text-2" id="text-orgf765f97">
<p>
Семафор (размера n) представляет собой обобщение мьютекса. Подобно мьютексу, семафор поддерживает операции захвата и освобождения, но захватить его одновременно могут до n процессов. Прочие процессы, которые попытаются захватить семафор, должны будут ждать освобождения. Дайте реализацию семафоров
а. в терминах мьютексов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-semaphore</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mutex</span> <span class="p">(</span><span class="nf">make-mutex</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">count-mutex</span> <span class="p">(</span><span class="nf">make-mutex</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">taken</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">semaphore</span> <span class="nv">command</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">command</span> <span class="ss">'acquire</span><span class="p">)</span>
	     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">taken</span> <span class="nv">n</span><span class="p">)</span>
		 <span class="p">(</span><span class="nf">begin</span>
		   <span class="p">(</span><span class="nf">count-mutex</span> <span class="ss">'acquire</span><span class="p">)</span>
		   <span class="p">(</span><span class="k">set! </span><span class="nv">taken</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">taken</span><span class="p">))</span>
		   <span class="p">(</span><span class="nf">count-mutex</span> <span class="ss">'release</span><span class="p">))</span>
		 <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">mutex</span> <span class="ss">'acquire</span><span class="p">)))))</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">command</span> <span class="ss">'release</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">begin</span>
		<span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">taken</span> <span class="mi">1</span><span class="p">)</span>
		 <span class="p">(</span><span class="nf">begin</span>
		   <span class="p">(</span><span class="nf">count-mutex</span> <span class="ss">'acquire</span><span class="p">)</span>
		   <span class="p">(</span><span class="k">set! </span><span class="nv">taken</span> <span class="p">(</span><span class="nb">- </span><span class="nv">taken</span> <span class="mi">1</span><span class="p">))</span>
		   <span class="p">(</span><span class="nf">count-mutex</span> <span class="ss">'release</span><span class="p">)))</span>
	     <span class="p">(</span><span class="nf">mutex</span> <span class="ss">'release</span><span class="p">))))</span>
    <span class="nv">semaphore</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">make-semaphore</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">s</span> <span class="ss">'acquire</span><span class="p">)</span>
<span class="p">(</span><span class="nf">s</span> <span class="ss">'release</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org651a987" class="outline-2">
<h2 id="org651a987">Упражнение 3.48</h2>
<div class="outline-text-2" id="text-org651a987">
<p>
Подробно объясните, почему метод избежания тупиков, описанный выше (т. е. счета нумеруются, и каждый процесс сначала пытается захватить счет с меньшим номером), в самом деле позволяет избежать тупика в задаче обмена балансов. Перепишите serialized-exchange с использованием этой идеи. (Придется также изменить make-account, так, чтобы каждый счет создавался вместе с номером, и чтобы этот номер можно было считать, послав соответствующее сообщение.)
</p>

<p>
В данном случае два процесса не могут захватить разные мьютексы из-за того что они отсортированы, поэтому если первый процесс захватит первый мьютекс второй должен дождаться его освобождения.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">serialized-exchange</span> <span class="nv">account1</span> <span class="nv">account2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">serializer1</span> <span class="ss">'serializer-for-bigger-id--acc</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">serializer2</span> <span class="ss">'serializer-for-smaller-id-acc</span><span class="p">))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">get-id</span> <span class="nv">account1</span><span class="p">)</span> <span class="p">(</span><span class="nf">get-id</span> <span class="nv">account2</span><span class="p">))</span>
	   <span class="p">(</span><span class="k">set! </span><span class="nv">serializer1</span> <span class="p">(</span><span class="nf">account1</span> <span class="ss">'serializer</span><span class="p">))</span>
	   <span class="p">(</span><span class="k">set! </span><span class="nv">serializer2</span> <span class="p">(</span><span class="nf">account2</span> <span class="ss">'serializer</span><span class="p">)))</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">set! </span><span class="nv">serializer1</span> <span class="p">(</span><span class="nf">account2</span> <span class="ss">'serializer</span><span class="p">))</span>
		<span class="p">(</span><span class="k">set! </span><span class="nv">serializer2</span> <span class="p">(</span><span class="nf">account1</span> <span class="ss">'serializer</span><span class="p">))))</span>
    <span class="p">((</span><span class="nf">serializer1</span> <span class="p">(</span><span class="nf">serializer2</span> <span class="nv">exchange</span><span class="p">))</span> <span class="nv">account1</span> <span class="nv">account2</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org9399a6a" class="outline-2">
<h2 id="org9399a6a">Упражнение 3.49</h2>
<div class="outline-text-2" id="text-org9399a6a">
<p>
Опишите сценарий, в котором вышеописанный механизм избежания тупиков не работает. (Подсказка: в задаче обмена счетов каждый процесс заранее знает, к каким счетам ему нужен будет доступ. Рассмотрите ситуацию, в которой процессу нужно сначала получить доступ к каким-то разделяемым ресурсам, прежде чем он сможет определить, какие ресурсы ему потребуются дополнительно.)
</p>

<p>
Например нам нужно полнить счет 1 и в зависимости от суммы на счете сделать перевод на x или y. А при пополнении счета y, нам нужно в зависимости от суммы перевести на 1 или x. Получается если сначала процесс захватит счет 1, а второй процесс захватит счет y, то может возникнуть ситуация deadlock, так как счету 1 надо выполнить перевод на y, а y надо выполнить перевод на 1.
</p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-33-modelirovanie-s-izmeniaemymi-dannymi/" class="u-url">SICP 3.3 Моделирование с изменяемыми данными.</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-33-modelirovanie-s-izmeniaemymi-dannymi/" rel="bookmark">
            <time class="published dt-published" datetime="2020-02-05T14:06:34+03:00" itemprop="datePublished" title="2020-02-05 14:06">2020-02-05 14:06</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-orgf182db6" class="outline-2">
<h2 id="orgf182db6">Упражнение 3.12</h2>
<div class="outline-text-2" id="text-orgf182db6">
<p>
Следующая процедура добавления элементов в список была приведена в главе 2.2.1
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">append </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">x</span><span class="p">)</span>
      <span class="nv">y</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">))))</span>
</pre></div>

<p>
Процедура append! похожа, но применяет mutator вместо конструктора.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">append!</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nf">last-pair</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">last-pair</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
      <span class="nv">x</span>
      <span class="p">(</span><span class="nf">last-pair</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))))</span>
</pre></div>

<p>
Рассмотрим следующие команды
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'c</span> <span class="ss">'d</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">append </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="nv">z</span>
<span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)</span>
<span class="nv">&lt;response&gt;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">w</span> <span class="p">(</span><span class="nf">append!</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="nv">w</span>
<span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)</span>
<span class="nv">&lt;response&gt;</span>
</pre></div>

<p>
Какие значения в пропущенных &lt;response&gt;. Нарисуйте структуру box-and-pointer что бы пояснить ответ.
</p>
<div class="highlight"><pre><span></span><span class="c1">;; в первом случае</span>
<span class="p">(</span><span class="nf">b</span><span class="p">)</span> <span class="c1">;; ссылка на x убирается формируется новый список, к которому добавляем y</span>
<span class="c1">;; во втором случае</span>
<span class="p">(</span><span class="nf">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span>
<span class="c1">;; x и w псевдонимы, к которым в конце добавляется y.</span>
</pre></div>

<p>
<img src="images/3.12.png" alt="nil"></p>
</div>
</div>


<div id="outline-container-orgfa76f23" class="outline-2">
<h2 id="orgfa76f23">Упражнение 3.13</h2>
<div class="outline-text-2" id="text-orgfa76f23">
<p>
Рассмотрим следующую процедуру make-cycle, которая использует last-pair описанную ранее.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-cycle</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nf">last-pair</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span>
</pre></div>

<p>
Нарисуйте box-and-pointer диаграмму, которая показывает структуру объекта z, полученного следующим образом
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nf">make-cycle</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span> <span class="ss">'c</span><span class="p">)))</span>
</pre></div>

<p>
<img src="images/3.13.png" alt="nil"></p>

<p>
Что произойдет если выполнить (last-pair z)?
</p>

<p>
Произойдет бесконечный поиск последнего элемента в цикле.
</p>
</div>
</div>

<div id="outline-container-orge75d16f" class="outline-2">
<h2 id="orge75d16f">Упражнение 3.14</h2>
<div class="outline-text-2" id="text-orge75d16f">
<p>
Следующая процедура часто применяется, несмотря на запутанность.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mystery</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">loop</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">x</span><span class="p">)</span>
	<span class="nv">y</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">temp</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">loop</span> <span class="nv">temp</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">loop</span> <span class="nv">x</span> <span class="o">'</span><span class="p">()))</span>
</pre></div>

<p>
Объясните что mastery делает. Допустим v это список
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">v</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span> <span class="ss">'c</span> <span class="ss">'d</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">w</span> <span class="p">(</span><span class="nf">mystery</span> <span class="nv">v</span><span class="p">))</span>
</pre></div>
<p>
Нарисуйте диаграмму для v и для w после выполнения w. Что будет выведено для v и w?
</p>

<p>
<img src="images/3.14.png" alt="nil"></p>

<p>
v будет ссылаться на список с единственным значением a. А w будет содержать перевернутый список значений v.
</p>
</div>
</div>

<div id="outline-container-org0f814e4" class="outline-2">
<h2 id="org0f814e4">Упражнение 3.15</h2>
<div class="outline-text-2" id="text-org0f814e4">
<p>
Нарисуйте диаграмму для структур после применения set-to-wow!
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z1</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z2</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-to-wow!</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'wow</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-to-wow!</span> <span class="nv">z1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-to-wow!</span> <span class="nv">z2</span><span class="p">)</span>
</pre></div>

<p>
<img src="images/3.15.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-org811a950" class="outline-2">
<h2 id="org811a950">Упражнение 3.16</h2>
<div class="outline-text-2" id="text-org811a950">
<p>
Бен решил написать процедуру которая подсчитывает количество пар в любом списке. "Это просто. Количество пар, это количество в car плюс количество в cdr плюс один, что бы учесть текущую пару."
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">count-pairs</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">))</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">count-pairs</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))</span>
	 <span class="p">(</span><span class="nf">count-pairs</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
	 <span class="mi">1</span><span class="p">)))</span>
</pre></div>

<p>
Покажите, что эта процедура ошибочна. В частности, приведите примеры  структур ровно из трех пар, для которых процедура вернет 3; вернет 4; вернет 7; вообще никогда не завершится.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-pairs</span> <span class="nv">z</span><span class="p">)</span> <span class="c1">;; 3</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">y</span> <span class="mi">99999</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-pairs</span> <span class="nv">z</span><span class="p">)</span> <span class="c1">;; 4</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">y</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-pairs</span> <span class="nv">z</span><span class="p">)</span> <span class="c1">;; 7</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nf">count-pairs</span> <span class="nv">z</span><span class="p">)</span> <span class="c1">;; Inf</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgeaf58ee" class="outline-2">
<h2 id="orgeaf58ee">Упражнение 3.17</h2>
<div class="outline-text-2" id="text-orgeaf58ee">
<p>
Напишите правильную версию процедуры count-pairs из упражнения 3.16, которая возвращает число различных пар в любой структуре. (Подсказка: просматривайте структуру, поддерживая при этом вспомогательную структуру, следящую за тем, какие пары уже были посчитаны.)
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">include?</span> <span class="nv">item</span> <span class="nv">positions</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">positions</span><span class="p">)</span>
      <span class="nv">false</span>
      <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">item</span> <span class="p">(</span><span class="nb">car </span><span class="nv">positions</span><span class="p">))</span> <span class="p">(</span><span class="nf">include?</span> <span class="nv">item</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">positions</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="nv">x</span> <span class="nv">checked</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">include?</span> <span class="nv">x</span> <span class="nv">checked</span><span class="p">))</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">checked</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">checked</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
	    <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="nv">checked</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="nv">checked</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)</span> <span class="nv">checked</span><span class="p">)</span>
	       <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="nv">z</span> <span class="o">'</span><span class="p">())</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">y</span> <span class="mi">99999</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="nv">z</span> <span class="o">'</span><span class="p">())</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">y</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="nv">z</span> <span class="o">'</span><span class="p">())</span>


<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">'</span><span class="p">()))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">y</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">x</span> <span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nf">count-uniq-pairs</span> <span class="nv">z</span> <span class="o">'</span><span class="p">())</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgfa02144" class="outline-2">
<h2 id="orgfa02144">Упражнение 3.18, 3.19</h2>
<div class="outline-text-2" id="text-orgfa02144">
<p>
Напишите процедуру, которая рассматривает список и определяет, содержится ли в нем цикл, то есть, не войдет ли программа, которая попытается добраться до конца списка, продвигаясь по полям cdr, в бесконечный цикл. Такие списки порождались в упражнении 3.13.
</p>

<p>
Переделайте упражнение 3.18, используя фиксированное количество памяти. (Тут нужна достаточно хитрая идея.)
</p>


<p>
Еще есть широко известные алгоритмы поиска повторов в последовательностях.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">floyed</span> <span class="nv">l</span><span class="p">)</span>
  <span class="c1">;; кролик бежит в два раза быстрее черепахи</span>
  <span class="c1">;; если цикл есть то он обагнав его на круг встретятся в некоторой точке</span>
  <span class="c1">;; запоминаем позицию кролика</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">same-point?</span> <span class="nv">tl</span> <span class="nv">hl</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">tl</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">hl</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">begin</span>
	  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">car </span><span class="nv">tl</span><span class="p">))</span>
	  <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">car </span><span class="nv">hl</span><span class="p">))</span>
	  <span class="nv">hl</span>
	  <span class="p">)</span>
	<span class="p">(</span><span class="nf">same-point?</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">tl</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">hl</span><span class="p">)))))</span>
  <span class="c1">;; далее бегут с равной минимальной скоростью</span>
  <span class="c1">;; кролик начинает с позиции предведущей встречи, а черепаха сначала</span>
  <span class="c1">;; они встретятся равно в начале цикла. потому что иначе получим</span>
  <span class="c1">;; противоречие что цикл есть.</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">start-repeat?</span> <span class="nv">tl</span> <span class="nv">hl</span> <span class="nv">index</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">tl</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">hl</span><span class="p">))</span>
	<span class="p">(</span><span class="nb">cons </span><span class="nv">tl</span> <span class="nv">index</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">start-repeat?</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">tl</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">hl</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">index</span> <span class="mi">1</span><span class="p">))))</span>
  <span class="c1">;; далее просто находим период, черепаха стоит, а кролик бежит пока позиции вновь не совпадут.</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">period?</span> <span class="nv">tl</span> <span class="nv">hl</span> <span class="nv">period</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">tl</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">hl</span><span class="p">))</span>
	<span class="nv">period</span>
	<span class="p">(</span><span class="nf">period?</span> <span class="nv">tl</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">hl</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">period</span> <span class="mi">1</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">hl</span> <span class="p">(</span><span class="nf">same-point?</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">l</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">start-repeat</span> <span class="p">(</span><span class="nf">start-repeat?</span> <span class="nv">l</span> <span class="nv">hl</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">tl</span> <span class="p">(</span><span class="nb">car </span><span class="nv">start-repeat</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">index</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">start-repeat</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define </span><span class="nv">period</span> <span class="p">(</span><span class="nf">period?</span> <span class="nv">tl</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">tl</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">index</span> <span class="nv">period</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-cycle2</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nf">last-pair</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)))</span>
  <span class="nv">x</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nf">make-cycle</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'a</span> <span class="ss">'b</span> <span class="ss">'c</span> <span class="ss">'d</span> <span class="ss">'e</span> <span class="ss">'f</span> <span class="ss">'g</span> <span class="ss">'h</span><span class="p">)))</span>
<span class="nv">z</span> <span class="c1">;Value: (a b . #0=(c d e f . #0#))</span>
<span class="p">(</span><span class="nf">floyed</span> <span class="nv">z</span><span class="p">)</span>
<span class="c1">;Value (2 . 4)</span>
</pre></div>

<p>
Порядок роста по месту 1.
</p>
</div>
</div>

<div id="outline-container-orgae49f6f" class="outline-2">
<h2 id="orgae49f6f">Упражнение 3.20</h2>
<div class="outline-text-2" id="text-orgae49f6f">
<p>
Нарисуйте диаграммы окружений, изображающие выполнение  последовательности выражений с помощью вышеприведенной процедурной реализации пар.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-x!</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">x</span> <span class="nv">v</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">set-y!</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="k">set! </span><span class="nv">y</span> <span class="nv">v</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'car</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'cdr</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'set-car!</span><span class="p">)</span> <span class="nv">set-x!</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'set-cdr!</span><span class="p">)</span> <span class="nv">set-y!</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Неопределенная операция -- CONS"</span> <span class="nv">m</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">car </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="ss">'car</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">z</span> <span class="ss">'cdr</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">set-car! </span><span class="nv">z</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">z</span> <span class="ss">'set-car!</span><span class="p">)</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">z</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">z</span> <span class="ss">'set-cdr!</span><span class="p">)</span> <span class="nv">new-value</span><span class="p">)</span>
  <span class="nv">z</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">z</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">car </span><span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nb">set-car! </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">z</span><span class="p">)</span> <span class="mi">17</span><span class="p">)</span>
<span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="c1">;; 17</span>
</pre></div>

<p>
<img src="images/3.20.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-org3df06f8" class="outline-2">
<h2 id="org3df06f8">Упражнение 3.21</h2>
<div class="outline-text-2" id="text-org3df06f8">
<p>
при добавлении элемента, ссылка на новый элемент сохраняется в два места, поэтому при распечатке выводится не только список элементов, но и вторая ссылка.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print-queue</span> <span class="nv">queue</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">queue</span><span class="p">))</span>
</pre></div>
</div>
</div>


<div id="outline-container-org89823d3" class="outline-2">
<h2 id="org89823d3">Упражнение 3.22</h2>
<div class="outline-text-2" id="text-org89823d3">
<p>
Вместо того, чтобы представлять очередь как пару указателей, можно построить ее в виде процедуры с внутренним состоянием. Это состояние будет включать указатели на начало и конец обыкновенного списка. Таким образом, make-queue будет иметь вид
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-queue</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">front-ptr</span> <span class="o">...</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">rear-ptr</span> <span class="o">...</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">определения</span> <span class="nv">внутренних</span> <span class="nv">процедур</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
    <span class="nv">dispatch</span><span class="p">))</span>
</pre></div>

<p>
Закончите определение make-queue и реализуйте операции над очередями с помощью этого представления.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-queue</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">front-ptr</span> <span class="o">'</span><span class="p">())</span>
	<span class="p">(</span><span class="nf">rear-ptr</span> <span class="o">'</span><span class="p">()))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">empty-queue?</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">front-ptr</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">front-queue</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-queue?</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">error</span> <span class="s">"FRONT вызвана с пустой очередью"</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">car </span><span class="nv">front-ptr</span><span class="p">)))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">insert</span> <span class="nv">item</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-pair</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="o">'</span><span class="p">())))</span>
	<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-queue?</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">front-ptr</span> <span class="nv">new-pair</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">rear-ptr</span> <span class="nv">new-pair</span><span class="p">)</span>
	       <span class="nv">front-ptr</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">else</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">rear-ptr</span> <span class="nv">new-pair</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">rear-ptr</span> <span class="nv">new-pair</span><span class="p">)</span>
	       <span class="nv">front-ptr</span><span class="p">))))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">delete</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-queue?</span><span class="p">)</span>
	     <span class="p">(</span><span class="nf">error</span> <span class="s">"DELETE! вызвана с пустой очередью"</span><span class="p">))</span>
	    <span class="p">(</span><span class="nf">else</span>
	     <span class="p">(</span><span class="k">set! </span><span class="nv">front-ptr</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">front-ptr</span><span class="p">))</span>
	     <span class="nv">front-ptr</span><span class="p">)))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'delete</span><span class="p">)</span> <span class="nv">delete</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'insert</span><span class="p">)</span> <span class="nv">insert</span><span class="p">)))</span>
    <span class="nv">dispatch</span><span class="p">))</span>
</pre></div>
</div>
</div>


<div id="outline-container-org87446e3" class="outline-2">
<h2 id="org87446e3">Упражнение 3.23</h2>
<div class="outline-text-2" id="text-org87446e3">
<p>
Дек (deque, double-ended queue, «двусторонняя очередь») представляет собой последовательность, элементы в которой могут добавляться и уничтожаться как с головы, так и с хвоста. На деках определены такие операции: конструктор make-deque, предикат empty-deque?, селекто-
ры front-deque и rear-deque, и мутаторы front-insert-deque!, rear-insert-deque!, front-delete-deque! и rear-delete-deque!. Покажите, как представить дек при помощи пар, и напишите реализацию операций .Все операции должны выполняться за Θ(1) шагов.
</p>

<p>
<img src="images/3.23.png" alt="nil"></p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-deque</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">front-ptr</span> <span class="o">'</span><span class="p">())</span>
	<span class="p">(</span><span class="nf">rear-ptr</span> <span class="o">'</span><span class="p">()))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">empty-queue?</span><span class="p">)</span> <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">front-ptr</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">rear-ptr</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">front-queue</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-queue?</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">error</span> <span class="s">"FRONT вызвана с пустой очередью"</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">car </span><span class="nv">front-ptr</span><span class="p">)))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rear-insert</span> <span class="nv">item</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-list</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="o">'</span><span class="p">())</span> <span class="o">'</span><span class="p">())))</span>
	<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-queue?</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">front-ptr</span> <span class="nv">new-list</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">rear-ptr</span> <span class="nv">front-ptr</span><span class="p">)</span>
	       <span class="nv">front-ptr</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">else</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">car </span><span class="nv">new-list</span><span class="p">)</span> <span class="nv">rear-ptr</span><span class="p">)</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">rear-ptr</span> <span class="nv">new-list</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">rear-ptr</span> <span class="nv">new-list</span><span class="p">)</span>
	       <span class="nv">front-ptr</span><span class="p">))))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">front-insert</span> <span class="nv">item</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-list</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">item</span> <span class="o">'</span><span class="p">())</span> <span class="o">'</span><span class="p">())))</span>
	<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-queue?</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">front-ptr</span> <span class="nv">new-list</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">rear-ptr</span> <span class="nv">front-ptr</span><span class="p">)</span>
	       <span class="nv">front-ptr</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">else</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">new-list</span> <span class="nv">front-ptr</span><span class="p">)</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">car </span><span class="nv">front-ptr</span><span class="p">)</span> <span class="nv">new-list</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">set! </span><span class="nv">front-ptr</span> <span class="nv">new-list</span><span class="p">)</span>
	       <span class="nv">front-ptr</span><span class="p">))))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">front-delete</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-queue?</span><span class="p">)</span>
	     <span class="p">(</span><span class="nf">error</span> <span class="s">"DELETE! вызвана с пустой очередью"</span><span class="p">))</span>
	    <span class="p">(</span><span class="nf">else</span>
	     <span class="p">(</span><span class="k">set! </span><span class="nv">front-ptr</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">front-ptr</span><span class="p">))</span>
	     <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">front-ptr</span><span class="p">))</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="p">(</span><span class="nb">car </span><span class="nv">front-ptr</span><span class="p">)</span> <span class="o">'</span><span class="p">()))</span>
	     <span class="nv">front-ptr</span><span class="p">)))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rear-delete</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-queue?</span><span class="p">)</span>
	     <span class="p">(</span><span class="nf">error</span> <span class="s">"DELETE! вызвана с пустой очередью"</span><span class="p">))</span>
	    <span class="p">(</span><span class="nf">else</span>
	     <span class="p">(</span><span class="k">set! </span><span class="nv">rear-ptr</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="nv">rear-ptr</span><span class="p">)))</span>
	     <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">rear-ptr</span><span class="p">))</span>
	       <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">rear-ptr</span> <span class="o">'</span><span class="p">()))</span>
	     <span class="nv">rear-ptr</span><span class="p">)))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rear</span><span class="p">)</span>
      <span class="nv">rear-ptr</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">front</span><span class="p">)</span>
      <span class="nv">front-ptr</span><span class="p">)</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'front-delete</span><span class="p">)</span> <span class="nv">front-delete</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'rear-delete</span><span class="p">)</span> <span class="nv">rear-delete</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'rear</span><span class="p">)</span> <span class="nv">rear</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'front</span><span class="p">)</span> <span class="nv">front</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'rear-insert</span><span class="p">)</span> <span class="nv">rear-insert</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'front-insert</span><span class="p">)</span> <span class="nv">front-insert</span><span class="p">)</span>
	    <span class="p">))</span>
    <span class="nv">dispatch</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">q</span> <span class="p">(</span><span class="nf">make-deque</span><span class="p">))</span>
<span class="p">((</span><span class="nf">q</span> <span class="ss">'rear-insert</span><span class="p">)</span> <span class="ss">'a</span><span class="p">)</span>
<span class="p">((</span><span class="nf">q</span> <span class="ss">'rear-insert</span><span class="p">)</span> <span class="ss">'b</span><span class="p">)</span>
<span class="p">((</span><span class="nf">q</span> <span class="ss">'rear-insert</span><span class="p">)</span> <span class="ss">'c</span><span class="p">)</span>
<span class="c1">;; #0=((a) . #1=((b . #0#) (c . #1#)))</span>

<span class="p">((</span><span class="nf">q</span> <span class="ss">'front-delete</span><span class="p">))</span>
<span class="p">((</span><span class="nf">q</span> <span class="ss">'rear-delete</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgc6e1fa9" class="outline-2">
<h2 id="orgc6e1fa9">Упражнение 3.24</h2>
<div class="outline-text-2" id="text-orgc6e1fa9">
<p>
В реализациях таблиц в этом разделе ключи всегда проверяются на равенство с помощью equal? (который, в свою очередь, зовется из assoc). Это не всегда то, что нужно. Например, можно представить себе таблицу с числовыми ключами, где не требуется точного совпадения с числом,
которое мы ищем, а нужно только совпадение с определенной допустимой ошибкой. Постройте конструктор таблиц make-table, который в качестве аргумента принимает процедуру same-key? для проверки равенства ключей. Make-table должна возвращать процедуру dispatch. через которую можно добраться до процедур lookup и insert! локальной таблицы. В реализациях таблиц в этом разделе ключи всегда проверяются на равенство с помощью equal? (который, в свою очередь, зовется из assoc). Это не всегда то, что нужно. Например, можно представить себе таблицу с числовыми ключами, где не требуется точного совпадения с числом, которое мы ищем, а нужно только совпадение с определенной допустимой ошибкой. Постройте
конструктор таблиц make-table, который в качестве аргумента принимает процедуру same-key? для проверки равенства ключей. Make-table должна возвращать процедуру dispatch. через которую можно добраться до процедур lookup и insert! локальной таблицы.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-table</span> <span class="nv">comparator</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">local-table</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'*table*</span><span class="p">)))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="nv">records</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">records</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	    <span class="p">((</span><span class="nf">comparator</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">records</span><span class="p">))</span> <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">))</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">records</span><span class="p">)))))</span>
<span class="o">...</span>
<span class="p">))</span>


<span class="p">(</span><span class="k">define </span><span class="nv">operation-table</span> <span class="p">(</span><span class="nf">make-table</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">&lt;= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="nv">tolerance</span><span class="p">))</span>
						   <span class="p">(</span><span class="nb">&gt;= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="nv">tolerance</span><span class="p">))</span>
					      <span class="p">))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org2484d94" class="outline-2">
<h2 id="org2484d94">Упражнение 3.25</h2>
<div class="outline-text-2" id="text-org2484d94">
<p>
Обобщая случаи одно- и двумерных таблиц, покажите, как можно реализовать таблицу, в которой элементы хранятся с произвольным количеством ключей и различные значения могут храниться с различным количеством ключей. Процедуры lookup и insert! должны принимать на входе
список ключей, с которыми требуется обратиться к таблице.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-table</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">local-table</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'*table*</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">display </span><span class="nv">local-table</span><span class="p">))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="nv">records</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">records</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">equal? </span><span class="nv">key</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">records</span><span class="p">))</span> <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">))</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">records</span><span class="p">)))))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lookup</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-lookup</span> <span class="nv">table</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">))))</span>
	  <span class="p">(</span><span class="k">if </span><span class="nv">record</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">keys</span><span class="p">)</span>
		  <span class="p">(</span><span class="nb">cdr </span><span class="nv">record</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">sub-lookup</span> <span class="nv">record</span> <span class="p">(</span><span class="nb">car </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">keys</span><span class="p">)))</span>
	      <span class="nv">false</span><span class="p">))</span>

	<span class="p">)</span>
      <span class="p">(</span><span class="nf">sub-lookup</span> <span class="nv">local-table</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="p">)</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">insert!</span> <span class="nv">value</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">table</span> <span class="nv">value</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">))))</span>
	  <span class="p">(</span><span class="k">if </span><span class="nv">record</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">keys</span><span class="p">)</span>
		  <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">record</span> <span class="nv">value</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">record</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">car </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">keys</span><span class="p">)))</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">keys</span><span class="p">)</span>
		  <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">table</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">)))</span>
		  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">sub-table</span> <span class="p">(</span><span class="nb">list </span><span class="nv">key</span><span class="p">)))</span>
		    <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">table</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">sub-table</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">)))</span>
		    <span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">sub-table</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">car </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">keys</span><span class="p">))</span>
		    <span class="p">)</span>
		  <span class="p">)</span>
	      <span class="p">))</span>
	  <span class="p">)</span>

      <span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">local-table</span> <span class="nv">value</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="ss">'ok</span><span class="p">)</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'lookup-proc</span><span class="p">)</span> <span class="nv">lookup</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'insert-proc!</span><span class="p">)</span> <span class="nv">insert!</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'print</span><span class="p">)</span> <span class="nv">print</span><span class="p">)</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown operation -- TABLE"</span> <span class="nv">m</span><span class="p">))))</span>
    <span class="nv">dispatch</span>
    <span class="p">)</span>
  <span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="nv">operation-table</span> <span class="p">(</span><span class="nf">make-table</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">get</span> <span class="p">(</span><span class="nf">operation-table</span> <span class="ss">'lookup-proc</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">put</span> <span class="p">(</span><span class="nf">operation-table</span> <span class="ss">'insert-proc!</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">print</span> <span class="p">(</span><span class="nf">operation-table</span> <span class="ss">'print</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span><span class="p">)</span>

<span class="p">(</span><span class="nf">put</span> <span class="mi">2</span> <span class="ss">'test</span> <span class="ss">'two</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="ss">'test</span> <span class="ss">'two</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="mi">1</span> <span class="ss">'test</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="ss">'test</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-orge41ab83" class="outline-2">
<h2 id="orge41ab83">Упражнение 3.26</h2>
<div class="outline-text-2" id="text-orge41ab83">
<p>
При поиске в таблице, как она реализована выше, приходится просматривать список записей. В сущности, это представление с неупорядоченным списком из раздела 2.3.3. Для больших таблиц может оказаться эффективнее организовать таблицу иначе. Опишите реализацию таблицы, в которой записи (ключ, значение) организованы в виде бинарного дерева, в предположении, что ключи можно каким-то образом упорядочить (например, численно или по алфавиту).
</p>

<p>
тут не стал делать общие операции для нескольких типов таблиц, но добавляя теги мы можем этого добиться, далее просто реализация хранения таблиц в виде бинарных деревьев, где к ветви дерева добавляется четвертое поле, которое хранит значение.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">tree</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">tree</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">tree</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">value-tree</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadddr </span><span class="nv">tree</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-tree</span> <span class="nv">entry</span> <span class="nv">left</span> <span class="nv">right</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">entry</span> <span class="nv">left</span> <span class="nv">right</span> <span class="nv">value</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-table</span><span class="p">)</span>
  <span class="c1">;; добавляем тег 'bin</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">empty-bin</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">'*bin*</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-bin?</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">value-tree</span> <span class="nv">record</span><span class="p">))</span> <span class="ss">'*bin*</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span> <span class="nv">value</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="nv">x</span> <span class="o">'</span><span class="p">()</span> <span class="o">'</span><span class="p">()</span> <span class="nv">value</span><span class="p">))</span>
	  <span class="p">((</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">set</span><span class="p">))</span> <span class="nv">set</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">set</span><span class="p">))</span>
	   <span class="p">(</span><span class="nf">make-tree</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">set</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">set</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">set</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">value-tree</span> <span class="nv">set</span><span class="p">)</span>
		      <span class="p">))</span>
	  <span class="p">((</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">set</span><span class="p">))</span>
	   <span class="p">(</span><span class="nf">make-tree</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">set</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">set</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">set</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">value-tree</span> <span class="nv">set</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">local-bin</span> <span class="p">(</span><span class="nf">empty-bin</span><span class="p">)))</span> <span class="c1">;; вместо списка бинарное дерево</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">display </span><span class="nv">local-bin</span><span class="p">))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">assoc-bin</span> <span class="nv">given-key</span> <span class="nv">tree</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">equal? </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="nv">tree</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">&gt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">assoc-bin</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)))</span>
	    <span class="p">((</span><span class="nb">&lt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">assoc-bin</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">)))))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lookup</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-lookup</span> <span class="nv">bin</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">(</span><span class="nf">assoc-bin</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">bin</span><span class="p">))))</span>
	  <span class="p">(</span><span class="k">if </span><span class="nv">record</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">keys</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">value-tree</span> <span class="nv">record</span><span class="p">)</span>
		  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">sub-bin?</span> <span class="nv">record</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">sub-lookup</span> <span class="p">(</span><span class="nf">value-tree</span> <span class="nv">record</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">keys</span><span class="p">))</span>
		      <span class="nv">false</span><span class="p">))</span>
	      <span class="nv">false</span><span class="p">))</span>

	<span class="p">)</span>
      <span class="p">(</span><span class="nf">sub-lookup</span> <span class="nv">local-bin</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="p">)</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">insert!</span> <span class="nv">value</span> <span class="nv">key</span> <span class="o">.</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">bin</span> <span class="nv">value</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">(</span><span class="nf">assoc-bin</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">bin</span><span class="p">))))</span>
	  <span class="p">(</span><span class="nb">display </span><span class="nv">record</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">if </span><span class="nv">record</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">keys</span><span class="p">)</span>
		  <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">record</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">left-branch</span> <span class="nv">record</span><span class="p">)</span>
					 <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">record</span><span class="p">)</span>
					 <span class="nv">value</span><span class="p">))</span>
		  <span class="p">(</span><span class="nf">sub-insert</span> <span class="p">(</span><span class="nb">cadddr </span><span class="nv">record</span><span class="p">)</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">car </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">keys</span><span class="p">)))</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">keys</span><span class="p">)</span>
		  <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">bin</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">bin</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
		  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">sub-bin</span> <span class="p">(</span><span class="nf">empty-bin</span><span class="p">)))</span>
		    <span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">bin</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">bin</span><span class="p">)</span> <span class="nv">sub-bin</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">sub-bin</span> <span class="nv">value</span> <span class="p">(</span><span class="nb">car </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">keys</span><span class="p">))</span>
		    <span class="p">)</span>
		  <span class="p">)</span>
	      <span class="p">))</span>
	  <span class="p">)</span>
      <span class="p">(</span><span class="nf">sub-insert</span> <span class="nv">local-bin</span> <span class="nv">value</span> <span class="nv">key</span> <span class="nv">keys</span><span class="p">)</span>
      <span class="ss">'ok</span><span class="p">)</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'lookup-proc</span><span class="p">)</span> <span class="nv">lookup</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'insert-proc!</span><span class="p">)</span> <span class="nv">insert!</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'print</span><span class="p">)</span> <span class="nv">print</span><span class="p">)</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown operation -- TABLE"</span> <span class="nv">m</span><span class="p">))))</span>
    <span class="nv">dispatch</span>
    <span class="p">)</span>
  <span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="nv">operation-table</span> <span class="p">(</span><span class="nf">make-table</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">get</span> <span class="p">(</span><span class="nf">operation-table</span> <span class="ss">'lookup-proc</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">put</span> <span class="p">(</span><span class="nf">operation-table</span> <span class="ss">'insert-proc!</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">print</span> <span class="p">(</span><span class="nf">operation-table</span> <span class="ss">'print</span><span class="p">))</span>
<span class="p">(</span><span class="nf">print</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'a</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'b</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'b</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="mi">1</span> <span class="ss">'test</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="mi">2</span> <span class="ss">'two</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgb4a0f33" class="outline-2">
<h2 id="orgb4a0f33">Упражнение 3.27</h2>
<div class="outline-text-2" id="text-orgb4a0f33">
<p>
Мемоизация (memoization) (называемая также табуляризация (tabulation)) — прием, который позволяет процедуре записывать в локальной таблице единожды вычисленные значения.
</p>

<p>
Нарисуйте диаграмму окружений, анализирующую вычисление (memo-fib 3). Объясните, почему memo-fib вычисляет n-е число Фибоначчи за число шагов, пропорциональное n. Стала бы схема работать, если бы мы определили memo-fib просто как (memoize fib)?
</p>

<p>
к моменту когда вычислим (memo-fib (- n 1)), значение для (memo-fib (-n 2) будет находиться в таблице, поэтому порядок роста такой функции будет n.
</p>

<p>
если определить memo-fib как (memoize fib) то будет запоминаться только последний результат таблицы, эти функции не эквивалентны.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lookup</span> <span class="nv">key</span> <span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">record</span>
	<span class="p">(</span><span class="nb">cdr </span><span class="nv">record</span><span class="p">)</span>
	<span class="nv">false</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="nv">records</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">records</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">equal? </span><span class="nv">key</span> <span class="p">(</span><span class="nb">caar </span><span class="nv">records</span><span class="p">))</span> <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">records</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">insert!</span> <span class="nv">key</span> <span class="nv">value</span> <span class="nv">table</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">key</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if </span><span class="nv">record</span>
	<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">record</span> <span class="nv">value</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">set-cdr! </span><span class="nv">table</span>
		  <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="nv">key</span> <span class="nv">value</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">table</span><span class="p">)))))</span>
  <span class="ss">'ok</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-table</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list </span><span class="ss">'*table*</span><span class="p">))</span>



<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
		 <span class="p">(</span><span class="nf">fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">memo-fib</span>
  <span class="p">(</span><span class="nf">memoize</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
	     <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
		   <span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
		   <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">memo-fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">memo-fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">memoize</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">table</span> <span class="p">(</span><span class="nf">make-table</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">table</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">previously-computed-result</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">x</span> <span class="nv">table</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">or </span><span class="nv">previously-computed-result</span>
	    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">result</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nb">display </span><span class="nv">result</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">insert!</span> <span class="nv">x</span> <span class="nv">result</span> <span class="nv">table</span><span class="p">)</span>
	      <span class="nv">result</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">fib</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="nf">memo-fib</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">((</span><span class="nf">memoize</span> <span class="nv">fib</span><span class="p">)</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>

<p>
<img src="images/3.27.png" alt="nil"></p>
</div>
</div>


<div id="outline-container-org7aecf10" class="outline-2">
<h2 id="org7aecf10">Упражнение 3.28</h2>
<div class="outline-text-2" id="text-org7aecf10">
<p>
Определите ИЛИ-элемент как элементарный функциональный блок. Ваш конструктор or-gate должен быть подобен and-gate.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">or-gate</span> <span class="nv">a1</span> <span class="nv">a2</span> <span class="nv">output</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">or-action-procedure</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-value</span>
	   <span class="p">(</span><span class="nf">logical-or</span> <span class="p">(</span><span class="nf">get-signal</span> <span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nf">get-signal</span> <span class="nv">a2</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">after-delay</span> <span class="nv">or-gate-delay</span>
		   <span class="p">(</span><span class="k">lambda </span><span class="p">()</span>
		     <span class="p">(</span><span class="nf">set-signal!</span> <span class="nv">output</span> <span class="nv">new-value</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">add-action!</span> <span class="nv">a1</span> <span class="nv">or-action-procedure</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">add-action!</span> <span class="nv">a2</span> <span class="nv">or-action-procedure</span><span class="p">)</span>
  <span class="ss">'ok</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgfc74320" class="outline-2">
<h2 id="orgfc74320">Упражнение 3.29</h2>
<div class="outline-text-2" id="text-orgfc74320">
<p>
Еще один способ создать ИЛИ-элемент — это собрать его как составной блок из И-элементов и инверторов. Определите процедуру or-gate, которая это осуществляет. Как время задержки ИЛИ-элемента выражается через and-gate-delay и inverter-delay?
</p>

<p>
(not (and (not a1) (not a2)))
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">or-gate</span> <span class="nv">a1</span> <span class="nv">a2</span> <span class="nv">output</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">inverter</span> <span class="nv">a1</span> <span class="nv">na1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">inventer</span> <span class="nv">a2</span> <span class="nv">na2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">and-gate</span> <span class="nv">na1</span> <span class="nv">na2</span> <span class="nv">andnot</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">inventer</span> <span class="nv">andnot</span> <span class="nv">output</span><span class="p">)</span>
  <span class="ss">'ok</span><span class="p">)</span>
</pre></div>
<p>
время задержки будет равно сумме всех задержек?
inventer-delay + inventer-delay + and-gate-delay + and-gate-delay + inventer-delay
как в последствии выяснится будет равно просто сумме and и or
</p>
</div>
</div>
<div id="outline-container-org7bb8808" class="outline-2">
<h2 id="org7bb8808">Упражнение 3.30</h2>
<div class="outline-text-2" id="text-org7bb8808">
<p>
Напишите процедуру riple-carry-adder, которая бы моделировала схему каскадного сумматора.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">riple-carry-adder</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">S</span> <span class="nv">Cn</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-carry-adder</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">S</span> <span class="nv">Cn</span> <span class="nv">res</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">A</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">cons </span><span class="nv">res</span> <span class="nv">Cn</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">begin</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">Sn</span> <span class="p">(</span><span class="nb">car </span><span class="nv">S</span><span class="p">)))</span>
	    <span class="p">(</span><span class="nf">full-adder</span> <span class="p">(</span><span class="nb">car </span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">B</span><span class="p">)</span> <span class="nv">Cn</span> <span class="nv">Sn</span> <span class="nv">Cn</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">iter-carry-adder</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">S</span><span class="p">)</span> <span class="nv">Cn</span> <span class="nv">Cn</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">Sn</span> <span class="nv">res</span><span class="p">))</span>
	  <span class="p">))))</span>

  <span class="p">(</span><span class="nf">iter-carry-adder</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">S</span> <span class="nv">Cn</span> <span class="o">'</span><span class="p">())</span>
  <span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga125d4e" class="outline-2">
<h2 id="orga125d4e">Упражнение 3.31</h2>
<div class="outline-text-2" id="text-orga125d4e">
<p>
Внутренняя процедура accept-action-procedure!, определенная в make-wire, требует, чтобы в момент, когда процедура-действие добавляется к проводу, она немедленно исполнялась. Объясните, зачем требуется такая инициализация. В частности, проследите работу процедуры half-adder из этого текста и скажите, как отличалась бы реакция системы, если бы accept-action-procedure! была определена как
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">accept-action-procedure!</span> <span class="nv">proc</span><span class="p">)</span>
  <span class="p">(</span><span class="k">set! </span><span class="nv">action-procedures</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">proc</span> <span class="nv">action-procedures</span><span class="p">)))</span>
</pre></div>

<p>
при инициализации только первого сигнала, результат будет 0 0 на sum и carry
</p>

<p>
в расписание не попадает интвентор, при выставлении только первого сигнала, поэтому схема совсем не будет работать.
</p>
</div>
</div>

<div id="outline-container-org2f909cc" class="outline-2">
<h2 id="org2f909cc">Упражнение 3.32</h2>
<div class="outline-text-2" id="text-org2f909cc">
<p>
Процедуры, предназначенные к выполнению в каждом временном отрезке, хранятся в виде очереди. Таким образом, процедуры для каждого отрезка вызываются в том же порядке, в котором они были добавлены к плану (первый пришел, первый ушел). Объясните, почему требуется использовать именно такой порядок. В частности, проследите поведение И-элемента, входы которого меняются с 0 на 1 и с 1 на 0 одновременно и скажите, как отличалось бы поведение, если бы мы хранили процедуры отрезка в обыкновенном списке, добавляя и убирая их только с головы (последний пришел, первый ушел).
</p>

<p>
initial (a1 a2)
(0 1)
(1 1) a1 -&gt; 1, out = 1
(1 0) a2 -&gt; 0, out = 0
то есть выполняя a2 последним получим правильный результат
</p>

<p>
если выполним в обратном порядке, получим неправильный
если же сначала выставляем a2, а потом a1, то получим правильный результат, но тогда каждый раз необходимо думать о последовательности.
(0 1)
(0 0) 0
(1 0) 1
</p>
</div>
</div>


<div id="outline-container-orgdea7e91" class="outline-2">
<h2 id="orgdea7e91">Упражнение 3.33</h2>
<div class="outline-text-2" id="text-orgdea7e91">
<p>
С помощью элементарных ограничений сумматор, умножитель и константа, определите процедуру averager (усреднитель), которая принимает три соединителя a, b и c, и обеспечивает условие, что значение c равно среднему арифметическому значений a и b.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">averager</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">av</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">s</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">half</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">adder</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">s</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">constant</span> <span class="mi">1</span><span class="nv">/2</span> <span class="nv">half</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">s</span> <span class="nv">half</span> <span class="nv">av</span><span class="p">)</span>
    <span class="ss">'ok</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">av</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>

<span class="p">(</span><span class="nf">averager</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">av</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-value!</span> <span class="nv">a</span> <span class="mi">2</span> <span class="ss">'user</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-value!</span> <span class="nv">b</span> <span class="mi">4</span> <span class="ss">'user</span><span class="p">)</span>
<span class="p">(</span><span class="nf">probe</span> <span class="s">"Average temp"</span> <span class="nv">av</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgdb0c0b7" class="outline-2">
<h2 id="orgdb0c0b7">Упражнение 3.34</h2>
<div class="outline-text-2" id="text-orgdb0c0b7">
<p>
Хьюго Дум хочет построить квадратор, блок-ограничение с двумя выводами, такое, что значение соединителя b на втором выводе всегда будет равно квадрату значения соединителя a на первом выводе. Он предлагает следующее простое устройство на основе умножителя:
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">squarer</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">a</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</pre></div>
<p>
В такой идее есть существенная ошибка. Объясните ее.
</p>

<p>
Не можем вычислить a по b
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">squarer</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">a</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="p">(</span><span class="nf">probe</span> <span class="s">"Squarer temp"</span> <span class="nv">a</span><span class="p">)</span>

<span class="p">(</span><span class="nf">squarer</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">(</span><span class="nf">set-value!</span> <span class="nv">b</span> <span class="mi">9</span> <span class="ss">'user</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org86c027a" class="outline-2">
<h2 id="org86c027a">Упражнение 3.35</h2>
<div class="outline-text-2" id="text-org86c027a">
<p>
Бен Битобор объясняет Хьюго, что один из способов избежать неприятностей в упражнении 3.34  — определить квадратор как новое элементарное ограничение. Заполните недостающие части в Беновой схеме процедуры, реализующей такое ограничение:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">squarer</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">process-new-value</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">has-value?</span> <span class="nv">b</span><span class="p">)</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">get-value</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">error</span> <span class="s">"square less than 0 -- SQUARER"</span> <span class="p">(</span><span class="nf">get-value</span> <span class="nv">b</span><span class="p">))</span>
	    <span class="nv">&lt;alternative1&gt;</span><span class="p">)</span>
	<span class="nv">&lt;alternative2&gt;</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">process-forget-value</span><span class="p">)</span> <span class="nv">&lt;body1&gt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">me</span> <span class="nv">request</span><span class="p">)</span> <span class="nv">&lt;body2&gt;</span><span class="p">)</span>
  <span class="nv">&lt;rest</span> <span class="nv">of</span> <span class="nv">definition&gt;</span>
  <span class="nv">me</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">squarer</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">process-new-value</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">has-value?</span> <span class="nv">b</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">get-value</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">error</span> <span class="s">"square less than 0 -- SQUARER"</span> <span class="p">(</span><span class="nf">get-value</span> <span class="nv">b</span><span class="p">))</span>
	       <span class="p">(</span><span class="nf">set-value!</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nf">get-value</span> <span class="nv">b</span><span class="p">))</span> <span class="nv">me</span><span class="p">)))</span>
	  <span class="p">((</span><span class="nf">has-value?</span> <span class="nv">a</span><span class="p">)</span>
	   <span class="p">(</span><span class="nf">set-value!</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">get-value</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">get-value</span> <span class="nv">a</span><span class="p">))</span> <span class="nv">me</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">process-forget-value</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">forget-value!</span> <span class="nv">a</span> <span class="nv">me</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">forget-value!</span> <span class="nv">b</span> <span class="nv">me</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">process-new-value</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">me</span> <span class="nv">request</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">request</span> <span class="ss">'I-have-a-value</span><span class="p">)</span>
	   <span class="p">(</span><span class="nf">process-new-value</span><span class="p">))</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">request</span> <span class="ss">'I-lost-my-value</span><span class="p">)</span>
	   <span class="p">(</span><span class="nf">process-forget-value</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">else</span>
	   <span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- SQUARER"</span> <span class="nv">request</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">connect</span> <span class="nv">a</span> <span class="nv">me</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">connect</span> <span class="nv">b</span> <span class="nv">me</span><span class="p">)</span>
  <span class="nv">me</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org8a5bd41" class="outline-2">
<h2 id="org8a5bd41">Упражнение 3.36</h2>
<div class="outline-text-2" id="text-org8a5bd41">
<p>
Допустим, что мы выполняем следующую последовательность действий в глобальном окружении:
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">set-value!</span> <span class="nv">a</span> <span class="mi">10</span> <span class="err">’</span><span class="nv">user</span><span class="p">)</span>
</pre></div>
<p>
В какой-то момент при вычислении set-value! будет выполнено следующее выражение из внутренней процедуры соединителя:
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">for-each-except</span> <span class="nv">setter</span> <span class="nv">inform-about-value</span> <span class="nv">constraints</span><span class="p">)</span>
</pre></div>
<p>
Нарисуйте диаграмму, изображающую окружение, в котором выполняется указанное выражение.
</p>

<p>
<img src="images/3.36.png" alt="nil"></p>
</div>
</div>

<div id="outline-container-orgfffde21" class="outline-2">
<h2 id="orgfffde21">Упражнение 3.37</h2>
<div class="outline-text-2" id="text-orgfffde21">
<p>
Процедура celsius-fahrenheit-converter выглядит громоздко по сравнению со стилем определения в формате выражения:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">celsius-fahrenheit-converter</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">c+</span> <span class="p">(</span><span class="nf">c*</span> <span class="p">(</span><span class="nf">c/</span> <span class="p">(</span><span class="nf">cv</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nf">cv</span> <span class="mi">5</span><span class="p">))</span>
	  <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cv</span> <span class="mi">32</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">C</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">F</span> <span class="p">(</span><span class="nf">celsius-fahrenheit-converter</span> <span class="nv">C</span><span class="p">))</span>
</pre></div>

<p>
Здесь c+, c* и т. п. — «ограничительные» версии арифметических операций. Например, c+ берет в виде аргументов два соединителя, и возвращает соединитель, который связан с ними ограничением-сумматором:
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">c+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">z</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">adder</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="nv">z</span><span class="p">))</span>
</pre></div>
<p>
Определите аналогичные процедуры для c-, c*, c/ и cv (константа), так, чтобы можно было определять составные ограничения, как в вышеприведенном примере 33.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">celsius-fahrenheit-converter</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">c+</span> <span class="p">(</span><span class="nf">c*</span> <span class="p">(</span><span class="nf">c/</span> <span class="p">(</span><span class="nf">cv</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nf">cv</span> <span class="mi">5</span><span class="p">))</span>
	  <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cv</span> <span class="mi">32</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">c+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">z</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">adder</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
    <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cv</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">constant</span> <span class="nv">value</span> <span class="nv">x</span><span class="p">)</span>
    <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">c*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">m</span><span class="p">)</span>
    <span class="nv">m</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">c/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">d</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">divider</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">d</span><span class="p">)</span>
    <span class="nv">d</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nf">make-connector</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">Z</span> <span class="p">(</span><span class="nf">celsius-fahrenheit-converter</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">set-value!</span> <span class="nv">x</span> <span class="mi">0</span> <span class="ss">'user</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get-value</span> <span class="nv">Z</span><span class="p">)</span> <span class="c1">;; 32</span>
</pre></div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-32-model-vychislenii-s-okruzheniiami/" class="u-url">SICP 3.2 Модель вычислений с окружениями</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-32-model-vychislenii-s-okruzheniiami/" rel="bookmark">
            <time class="published dt-published" datetime="2020-02-04T12:50:12+03:00" itemprop="datePublished" title="2020-02-04 12:50">2020-02-04 12:50</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-orgd02c925" class="outline-2">
<h2 id="orgd02c925">Упражнение 3.9</h2>
<div class="outline-text-2" id="text-orgd02c925">
<p>
Покажите структуру окружений для вычисления факториала.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">factorial</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="mi">1</span>
      <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">factorial</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">factorial</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>

<p>
определение процедуры в глобальной области. создается окружение где n=6, оно ссылается на глобальную область.
</p>

<p>
(* 6 (factorial 5))
</p>

<p>
E1(n=6) E2(n=5) E3(n=4) E4(n=3) E5(n=2) E6(n=1), все ссылаются на глобальную область видимости.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">factorial</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fact-iter</span> <span class="mi">1</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fact-iter</span> <span class="nv">product</span> <span class="nv">counter</span> <span class="nv">max-count</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">counter</span> <span class="nv">max-count</span><span class="p">)</span>
      <span class="nv">product</span>
      <span class="p">(</span><span class="nf">fact-iter</span> <span class="p">(</span><span class="nb">* </span><span class="nv">counter</span> <span class="nv">product</span><span class="p">)</span>
		 <span class="p">(</span><span class="nb">+ </span><span class="nv">counter</span> <span class="mi">1</span><span class="p">)</span>
		 <span class="nv">max-count</span><span class="p">)))</span>
</pre></div>

<p>
E1 - n: 6               -&gt; G
   (fact-iter 1 1 6)
</p>

<p>
E2 - product: 1         -&gt; G
</p>
<ul class="org-ul">
<li>counter: 1</li>
<li>max-count: 6</li>
</ul>
<p>
(fact-iter 1 2 6)
</p>

<p>
E3 - product 1          -&gt; G
</p>
<ul class="org-ul">
<li>counter 2</li>
<li>max-count 6</li>
</ul>
<p>
   (fact-iter 1 2 6)
…
</p>
</div>
</div>


<div id="outline-container-org831495e" class="outline-2">
<h2 id="org831495e">Упражнение 3.10</h2>
<div class="outline-text-2" id="text-org831495e">
<p>
Проиллюстрируйте структуры окружений для следующей процедуры и вызовов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-withdraw</span> <span class="nv">initial-amount</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">balance</span> <span class="nv">initial-amount</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">amount</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
		 <span class="nv">balance</span><span class="p">)</span>
	  <span class="s">"Insufficient funds"</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">W1</span> <span class="p">(</span><span class="nf">make-withdraw</span> <span class="mi">100</span><span class="p">))</span>

<span class="p">(</span><span class="nf">W1</span> <span class="mi">50</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">W2</span> <span class="p">(</span><span class="nf">make-withdraw</span> <span class="mi">100</span><span class="p">))</span>
</pre></div>

<p>
учтите что let это синтаксический сахар над lambda, то есть следующие записи эквивалентны
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">&lt;var&gt;</span> <span class="nv">&lt;exp&gt;</span><span class="p">))</span> <span class="nv">&lt;body&gt;</span><span class="p">)</span>
<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">&lt;var&gt;</span><span class="p">)</span> <span class="nv">&lt;body&gt;</span><span class="p">)</span> <span class="nv">&lt;exp&gt;</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-withdraw</span> <span class="nv">initial-amount</span><span class="p">)</span>
  <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">balance</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">amount</span><span class="p">)</span> <span class="o">...</span><span class="p">))</span> <span class="nv">initial-amount</span><span class="p">))</span>
</pre></div>

<p>
<img src="images/3.10.png" alt="nil"></p>

<p>
(W1 50)
</p>

<p>
Set! повлияет на E2, initial-mount останется неизменным в первом окружении.
</p>
</div>
</div>


<div id="outline-container-org4792190" class="outline-2">
<h2 id="org4792190">Упражнение 3.11</h2>
<div class="outline-text-2" id="text-org4792190">
<p>
Проиллюстрируйте структуру окружений для следующей процедуры и вызовов
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account</span> <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	       <span class="nv">balance</span><span class="p">)</span>
	<span class="s">"Insufficient funds"</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">withdraw</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">deposit</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
		       <span class="nv">m</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">acc</span> <span class="p">(</span><span class="nf">make-account</span> <span class="mi">50</span><span class="p">))</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">60</span><span class="p">)</span>
</pre></div>

<p>
<img src="images/3.11.png" alt="nil"></p>

<p>
Где хранится внутреннее состояние acc? 
Состояние хранится в окружении E1.
</p>

<p>
Предположим, что мы определяем еще один счет.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">acc2</span> <span class="p">(</span><span class="nf">make-account</span> <span class="mi">100</span><span class="p">))</span>
</pre></div>
<p>
Каким образом удается не смешивать внутренние состояния двух счетов?
На каждый счет создаются отдельные окружения, никак не пересекающиеся.
</p>

<p>
Какие части структуры окружений общие у acc и acc2?
Только глобальная область видимости, то есть определение make-account.
</p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-31-naznacheniia-i-lokalnoye-sostoianiia/" class="u-url">SICP 3.1 Назначения и локальноые состояния.</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-31-naznacheniia-i-lokalnoye-sostoianiia/" rel="bookmark">
            <time class="published dt-published" datetime="2020-02-02T11:46:58+03:00" itemprop="datePublished" title="2020-02-02 11:46">2020-02-02 11:46</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-org908d786" class="outline-2">
<h2 id="org908d786">Упражнение 3.1</h2>
<div class="outline-text-2" id="text-org908d786">
<p>
определите сумматор
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">A</span> <span class="p">(</span><span class="nf">make-accumulator</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">10</span><span class="p">)</span>
<span class="mi">15</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">10</span><span class="p">)</span>
<span class="mi">25</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-accumulator</span> <span class="nv">sum</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">begin</span>
	   <span class="p">(</span><span class="k">set! </span><span class="nv">sum</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">sum</span> <span class="nv">x</span><span class="p">))</span>
	   <span class="nv">sum</span>
	   <span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgaddaa17" class="outline-2">
<h2 id="orgaddaa17">Упражнение 3.2</h2>
<div class="outline-text-2" id="text-orgaddaa17">
<p>
в программах для тестирования важно уметь считать количество вызовов функции. Напишите процедуру, которая считает количество вызовов например функции sqrt.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">make-monitored</span> <span class="nv">sqrt</span><span class="p">))</span>

<span class="p">(</span><span class="nf">s</span> <span class="mi">100</span><span class="p">)</span>
<span class="mi">10</span>

<span class="p">(</span><span class="nf">s</span> <span class="ss">'how-many-calls?</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-monitor</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">how-many-call?</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">incretement</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">begin</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">how-many-call?</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">how-many-call?</span> <span class="mi">1</span><span class="p">))</span>
      <span class="nv">f</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'how-many-call?</span><span class="p">)</span> <span class="nv">how-many-call?</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">((</span><span class="nf">incretement</span><span class="p">)</span> <span class="nv">m</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">s</span> <span class="p">(</span><span class="nf">make-monitor</span> <span class="nv">sqrt</span><span class="p">))</span>
<span class="p">(</span><span class="nf">s</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">(</span><span class="nf">s</span> <span class="ss">'how-many-call?</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-org7801aeb" class="outline-2">
<h2 id="org7801aeb">Упражнение 3.3</h2>
<div class="outline-text-2" id="text-org7801aeb">
<p>
Измените процедуру make-account, чтобы она принимала пароль в конструкторе. И пощволяла списание только при передаче его в параметре.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">acc</span> <span class="p">(</span><span class="nf">make-account</span> <span class="mi">100</span> <span class="ss">'secret-password</span><span class="p">))</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'secret-password</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">40</span><span class="p">)</span>
<span class="mi">60</span>

<span class="p">((</span><span class="nf">acc</span> <span class="ss">'some-other-password</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>
<span class="s">"Incorrect password"</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account</span> <span class="nv">balance</span> <span class="nv">password</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	       <span class="nv">balance</span><span class="p">)</span>
	<span class="s">"Insufficient funds"</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">permission-denied</span> <span class="o">.</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">"Incorrect password"</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">pass</span> <span class="nv">func</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">pass</span> <span class="nv">password</span><span class="p">))</span> <span class="nv">permission-denied</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">func</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">withdraw</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">func</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">deposit</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
		       <span class="nv">func</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">acc</span> <span class="p">(</span><span class="nf">make-account</span> <span class="mi">100</span> <span class="ss">'secret-password</span><span class="p">))</span>
<span class="nv">acc</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'secret-password</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'some-other-password</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orge82de4f" class="outline-2">
<h2 id="orge82de4f">Упражнение 3.4</h2>
<div class="outline-text-2" id="text-orge82de4f">
<p>
Измените процедуру make-account, что бы при 7 вызовах с неверным паролем возвращалась процедура call-the-cops.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account</span> <span class="nv">balance</span> <span class="nv">password</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	<span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	       <span class="nv">balance</span><span class="p">)</span>
	<span class="s">"Insufficient funds"</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
    <span class="nv">balance</span><span class="p">)</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">permission-denied</span> <span class="o">.</span> <span class="nv">m</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="s">"Incorrect password"</span><span class="p">))</span>


  <span class="p">(</span><span class="k">define </span><span class="nv">monitor-error-password</span> <span class="p">(</span><span class="nf">make-monitor</span> <span class="nv">permission-denied</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">call-limit?</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">monitor-error-password</span> <span class="ss">'how-many-call?</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">display </span><span class="s">"Viu viu viu viu.."</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">pass</span> <span class="nv">func</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">pass</span> <span class="nv">password</span><span class="p">))</span> <span class="p">(</span><span class="nf">begin</span>
				       <span class="p">(</span><span class="nf">call-limit?</span><span class="p">)</span>
				       <span class="nv">monitor-error-password</span><span class="p">))</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">func</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">withdraw</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">func</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">deposit</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
		       <span class="nv">func</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">acc</span> <span class="p">(</span><span class="nf">make-account</span> <span class="mi">100</span> <span class="ss">'secret-password</span><span class="p">))</span>
<span class="nv">acc</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'secret-password</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">((</span><span class="nf">acc</span> <span class="ss">'some-other-password</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org548cfbb" class="outline-2">
<h2 id="org548cfbb">Упражнение 3.5</h2>
<div class="outline-text-2" id="text-org548cfbb">
<p>
Реализуйте интегрирование методом Монте-Карло в виде процедуры estimateintegral, которая в качестве аргументов принимает предикат P, верхнюю и нижнюю границы прямоугольника x1, x2, y1 и y2, а также число проверок, которые мы должны осуществить, чтобы оценить отношение площадей. Ваша процедура должна использовать ту же самую процедуру monte-carlo, которая выше использовалась для оценки значения π. Оцените π при помощи estimate-integral.
</p>


<div class="highlight"><pre><span></span><span class="c1">;; окружность</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">predicate</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="mi">7</span><span class="p">)))</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">3</span><span class="p">)))</span>

<span class="c1">;; x от 2 до 8</span>
<span class="c1">;; y от 4 до 10</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">random-in-range</span> <span class="nv">low</span> <span class="nv">high</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">range</span> <span class="p">(</span><span class="nb">- </span><span class="nv">high</span> <span class="nv">low</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">low</span> <span class="p">(</span><span class="nf">random</span> <span class="nv">range</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">estimateintegral</span> <span class="nv">P</span> <span class="nv">min-x</span> <span class="nv">max-x</span> <span class="nv">min-y</span> <span class="nv">max-y</span> <span class="nv">trials</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">test</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">P</span>
     <span class="p">(</span><span class="nf">random-in-range</span> <span class="nv">min-x</span> <span class="nv">max-x</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">random-in-range</span> <span class="nv">min-y</span> <span class="nv">max-y</span><span class="p">)))</span>

  <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">monte-carlo</span> <span class="nv">trials</span> <span class="nv">test</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">- </span><span class="nv">max-x</span> <span class="nv">min-x</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">max-y</span> <span class="nv">min-y</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">estimateintegral</span> <span class="nv">predicate</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">10</span> <span class="mi">100000</span><span class="p">)</span>
</pre></div>

<p>
результат получился равен 26.97948, π = 2.99. Что бы получить лучшие значения нужно брать сетку с меньшим интервалом. Или например оценивать на окружности с большим радиусом.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">predicate</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">25</span><span class="p">))</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="mi">25</span><span class="p">)))</span> <span class="p">(</span><span class="nf">square</span> <span class="mi">25</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">estimateintegral</span> <span class="nv">predicate</span> <span class="mi">0</span> <span class="mi">50</span> <span class="mi">0</span> <span class="mi">50</span> <span class="mi">100000</span><span class="p">)</span>
<span class="c1">;; 113/4</span>
<span class="c1">;; 3.1388</span>
</pre></div>
</div>
</div>


<div id="outline-container-org75f8c30" class="outline-2">
<h2 id="org75f8c30">Упражнение 3.6</h2>
<div class="outline-text-2" id="text-org75f8c30">
<p>
Полезно иметь возможность сбросить генератор случайных чисел, чтобы получить последовательность, которая начинается с некоторого числа. Постройте новую процедуру rand, которая вызывается с аргументом. Этот аргумент должен быть либо символом generate, либо символом reset. Процедура работает так: (rand 'generate) порождает новое случайное число; ((rand 'reset) (новое-значение)) сбрасывает внутреннюю переменную состояния в указанное новое значение. Таким образом, сбрасывая значения, можно получать повторяющиеся последовательности. Эта возможность очень полезна при тестировании и отладке программ, использующих случайные числа.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">rand</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">random-init</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rand-update</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">7</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">8</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">9</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">9</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">6</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">6</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">= </span><span class="nv">random-init</span> <span class="mi">7</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
	    <span class="p">))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">generate</span><span class="p">)</span>
      <span class="p">(</span><span class="k">set! </span><span class="nv">random-init</span> <span class="p">(</span><span class="nf">rand-update</span><span class="p">))</span>
      <span class="nv">random-init</span><span class="p">)</span>

    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">m</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'reset</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
			      <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">random-init</span> <span class="nv">x</span><span class="p">)</span>
				     <span class="nv">x</span><span class="p">)))</span>
	    <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'generate</span><span class="p">)</span> <span class="p">(</span><span class="nf">generate</span><span class="p">))))</span>
    <span class="p">))</span>

<span class="p">((</span><span class="nf">rand</span> <span class="ss">'reset</span><span class="p">)</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">(</span><span class="nf">rand</span> <span class="ss">'generate</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-org8c0b159" class="outline-2">
<h2 id="org8c0b159">Упражнение 3.7</h2>
<div class="outline-text-2" id="text-org8c0b159">
<p>
Нужно написать процедуру связанного аккаунта, что бы как новый так и старый пользователи могли с ним работать.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">peter-acc</span> <span class="p">(</span><span class="nf">make-account</span> <span class="mi">100</span> <span class="ss">'secret</span><span class="p">))</span>
<span class="nv">peter-acc</span>
<span class="p">((</span><span class="nf">peter-acc</span> <span class="ss">'secret</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">((</span><span class="nf">peter-acc</span> <span class="ss">'some-other-password</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>
<span class="p">((</span><span class="nf">peter-acc</span> <span class="ss">'secret</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-joint</span> <span class="nv">account</span> <span class="nv">acc-pass</span> <span class="nv">new-pass</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display </span><span class="p">((</span><span class="nf">account</span> <span class="nv">acc-pass</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">equal? </span><span class="p">((</span><span class="nf">account</span> <span class="nv">acc-pass</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="s">"Incorrect password"</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">error</span> <span class="s">"Incorrect password"</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">permission-denied</span> <span class="o">.</span> <span class="nv">m</span><span class="p">)</span>
    <span class="s">"Incorrect password"</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">monitor-error-password</span> <span class="p">(</span><span class="nf">make-monitor</span> <span class="nv">permission-denied</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">call-limit?</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">monitor-error-password</span> <span class="ss">'how-many-call?</span><span class="p">)</span> <span class="mi">7</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">display </span><span class="s">"Viu viu viu viu.."</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">account</span> <span class="nv">acc-pass</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">amount</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">account</span> <span class="nv">acc-pass</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">amount</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">pass</span> <span class="nv">func</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">not </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">pass</span> <span class="nv">new-pass</span><span class="p">))</span> <span class="p">(</span><span class="nf">begin</span>
				       <span class="p">(</span><span class="nf">call-limit?</span><span class="p">)</span>
				       <span class="nv">monitor-error-password</span><span class="p">))</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">func</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">withdraw</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">func</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">deposit</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
		       <span class="nv">func</span><span class="p">))))</span>
  <span class="nv">dispatch</span>
  <span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="nv">paul-acc</span>
  <span class="p">(</span><span class="nf">make-joint</span> <span class="nv">peter-acc</span> <span class="ss">'secret</span> <span class="ss">'open-sesam</span><span class="p">))</span>
<span class="p">((</span><span class="nf">paul-acc</span> <span class="ss">'open-sesam</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-org9a84ce3" class="outline-2">
<h2 id="org9a84ce3">Упражнение 3.8</h2>
<div class="outline-text-2" id="text-org9a84ce3">
<p>
Определите простую процедуру f, чтобы вычисление (+ (f 0) (f 1)) возвращало 0, если аргументы + вычисляются слева направо, и 1, если они вычисляются справа налево.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">y</span> <span class="mi">0</span><span class="p">))</span>
	    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
		       <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))))</span>

<span class="c1">;; слева направо, сумма 0</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">;; 0</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; 0</span>

<span class="c1">;; справа налево 1</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; 1</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">;; 0</span>


<span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">f</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>

<p>
справа налево
</p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-25-sistemy-s-obshchimi-operatsiiami/" class="u-url">SICP 2.5 Системы с общими операциями.</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-25-sistemy-s-obshchimi-operatsiiami/" rel="bookmark">
            <time class="published dt-published" datetime="2020-01-25T20:11:07+03:00" itemprop="datePublished" title="2020-01-25 20:11">2020-01-25 20:11</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>
Системы с общими операциями не только для разных представлений, но и для разного числа аргументов.
</p>

<div id="outline-container-org3d2b23d" class="outline-2">
<h2 id="org3d2b23d">Упражнение 2.77</h2>
<div class="outline-text-2" id="text-org3d2b23d">
<p>
Луис Разумный пытается выполнить процедуру (magnitude z) где z объект комплексного числа как на изображении.
</p>

<p>
<img src="images/ch2-Z-G-65.gif" alt="nil"></p>

<p>
К его удивлению вместо числа, он получает ошибку ;No method for these types – APPLY-GENERIC (magnitude (complex)). Он показывает результат Алисе. Она говорит что пакет custom, не имеет селекторов magnitude, .. и предлагает добавить их в пакет.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">put</span> <span class="ss">'real-part</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span> <span class="nv">real-part</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'imag-part</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span> <span class="nv">imag-part</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'magnitude</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span> <span class="nv">magnitude</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'angle</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span> <span class="nv">angle</span><span class="p">)</span>

<span class="p">(</span><span class="nb">magnitude </span><span class="p">(</span><span class="nf">make-complex-from-mag-ang</span> <span class="mi">10</span> <span class="mf">0.5</span><span class="p">))</span>
</pre></div>

<p>
Объясните почему это будет работать? Сколько раз вызывается apply-generic? Какая процедура выполняется в каждом случае?
</p>

<p>
apply-generic вызывается два раза, на первом этапе происходит отображение на процедуру magnitude только с другим тегом, а во втором случае происходит отображение процедуру на внутреннюю процедуру поката polar.
</p>

<p>
[Entering #[compound-procedure 88 magnitude]
    Args: (complex polar 10 . .5)]
[Entering #[compound-procedure 88 magnitude]
    Args: (polar 10 . .5)]
[10
      &lt;== #[compound-procedure 88 magnitude]
    Args: (polar 10 . .5)]
[10
      &lt;== #[compound-procedure 88 magnitude]
    Args: (complex polar 10 . .5)]
</p>
</div>
</div>

<div id="outline-container-org48cfd39" class="outline-2">
<h2 id="org48cfd39">Упражнение 2.78</h2>
<div class="outline-text-2" id="text-org48cfd39">
<p>
Внутренние процедуры scheme-number по существу просто вызывают процедуры +/-/.. Не возможно использовать примитивы языка напрямую, потому что наша система тип-тег требует что бы каждый объект имел тег, в тоже время все реализации Lisp имеют внутренню систему типов. Примитивы symbol? number? определяют являются ли объекты примитивными типами. Измените определение type-tag, contents и attach-tag, что бы наша система получила преимущество использования внутренних типов Scheme. То есть функции должны работать по прежнему, но для операции над простыми числами не требуется дополнительный конструктор, который возвращает пару тип значение.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-scheme-number-package</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'sub</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'mul</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'div</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-scheme-number-package</span><span class="p">)</span> <span class="c1">;; установка пакета</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">attach-tag</span> <span class="nv">type-tag</span> <span class="nv">contents</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">number? </span><span class="nv">contents</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="ss">'scheme-number</span> <span class="nv">contents</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="nv">type-tag</span> <span class="nv">contents</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">type-tag</span> <span class="nv">datum</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">datum</span><span class="p">)</span> <span class="ss">'scheme-number</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">pair? </span><span class="nv">datum</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">datum</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Bad tagged datum -- TYPE-TAG"</span> <span class="nv">datum</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">contents</span> <span class="nv">datum</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">datum</span><span class="p">)</span> <span class="nv">datum</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">pair? </span><span class="nv">datum</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">datum</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Bad tagged datum -- CONTENTS"</span> <span class="nv">datum</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">add</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; 3</span>
</pre></div>
</div>
</div>


<div id="outline-container-org7b91fc1" class="outline-2">
<h2 id="org7b91fc1">Упражнение 2.79, 2.80</h2>
<div class="outline-text-2" id="text-org7b91fc1">
<p>
Определите общую процедуру equ? которая проверяет эквивалентность двух чисел. Процедура должна работать с обычными, рациональными и комплексными числами.
</p>

<p>
Определите общую процедуру =zero?
</p>

<div class="highlight"><pre><span></span><span class="c1">;; в интерфейсах пакетов</span>
<span class="c1">;; для обычных</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'equ?</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)))</span>
<span class="c1">;; для комплексных</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'equ?</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span> <span class="nv">complex</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">real-part </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">real-part </span><span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">imag-part </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">imag-part </span><span class="nv">y</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">magnitude </span><span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>
<span class="c1">;; для рациональных</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'equ?</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span> <span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">)))</span>
<span class="c1">;; общее определение</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">equ?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'equ?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">=zero?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'=zero?</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">=zero?</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">=zero?</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">equ?</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">equ?</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">make-complex-from-mag-ang</span> <span class="mi">10</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">equ?</span> <span class="p">(</span><span class="nf">make-complex-from-mag-ang</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">equ?</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">equ?</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">2</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">0</span> <span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</div>


<div id="outline-container-orge1b2234" class="outline-2">
<h2 id="orge1b2234">Упражнение 2.81</h2>
<div class="outline-text-2" id="text-orge1b2234">
<p>
Луис Разумный заметил что apply-generic может приводить аргументы, даже если они одного типа. Поэтому, он рассудил, что мы должны поместить процедуры приведения одинаковых типов в таблицу приведения.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scheme-number-&gt;scheme-number</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">complex-&gt;complex</span> <span class="nv">z</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put-coercion</span> <span class="ss">'scheme-number</span> <span class="ss">'scheme-number</span>
	      <span class="nv">scheme-number-&gt;scheme-number</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put-coercion</span> <span class="ss">'complex</span> <span class="ss">'complex</span> <span class="nv">complex-&gt;complex</span><span class="p">)</span>
</pre></div>

<p>
a. С установленными процедурами Луиса, что произойдет если вызвать apply-generic с двумя аргументами типа scheme-number или двумя аргументами типа complex для операции которой нет в таблице этих типов? к примеру зададим общую процедуру экспоненты:
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">exp </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'exp</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="c1">;; following added to Scheme-number package</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'exp</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span> <span class="nv">scheme-number</span><span class="p">)</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nb">expt </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span> <span class="c1">; using primitive expt</span>
</pre></div>

<p>
и вызовем её для комплексных чисел.
</p>

<p>
произойдет рекурсивный вызов apply-generic.
</p>

<p>
b. Прав ли Луис что дописал эти преобразования типов?
Код Луиса лишний, apply-generic и так работает.
</p>

<p>
с. Измените apply-generic чтобы он не пытался искать в таблице приведения типов, если типы аргументов одинаковые.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">proc</span>
	  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">args</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
	      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">type-tags</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">type2</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">type-tags</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">a1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">a2</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">args</span><span class="p">)))</span>
		<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">type1</span> <span class="nv">type2</span><span class="p">)</span>
		    <span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span>
			   <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
		    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">t1-&gt;t2</span> <span class="p">(</span><span class="nf">get-coercion</span> <span class="nv">type1</span> <span class="nv">type2</span><span class="p">))</span>
			  <span class="p">(</span><span class="nf">t2-&gt;t1</span> <span class="p">(</span><span class="nf">get-coercion</span> <span class="nv">type2</span> <span class="nv">type1</span><span class="p">)))</span>
		      <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">t1-&gt;t2</span>
			     <span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="p">(</span><span class="nf">t1-&gt;t2</span> <span class="nv">a1</span><span class="p">)</span> <span class="nv">a2</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">t2-&gt;t1</span>
			     <span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="nv">a1</span> <span class="p">(</span><span class="nf">t2-&gt;t1</span> <span class="nv">a2</span><span class="p">)))</span>
			    <span class="p">(</span><span class="nf">else</span>
			     <span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span>
				    <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))))))</span>
		<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span>
		       <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))))))</span>
</pre></div>
</div>
</div>


<div id="outline-container-org36fb671" class="outline-2">
<h2 id="org36fb671">Упражнение 2.82</h2>
<div class="outline-text-2" id="text-org36fb671">
<p>
Покажите как обобщить apply-generic для обработки приведения типов множественных аргументов. Одна из стратегий, попытка привести все аргументы к типу первого аргумента, затем к типу второго и так далее.
Дайте пример когда такая стратегия не работает (более того она может не сработать и для двух аргументов).
</p>

<p>
Если у нас есть три типа T1, T2, T3 и задана операция для T1, T2, T2 в таблице операций, то мы не найдем эту операцию, потому что при полном приведении типов сможем получить только T1 T2 T3, T1 T1 T1, T2 T2 T2, T3 T3 T3.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">map-args</span> <span class="nv">args</span> <span class="nv">type-tags</span> <span class="nv">cdr-type-tags</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">try-coercion</span> <span class="nv">args</span> <span class="nv">type-list</span> <span class="nv">target-type</span> <span class="nv">res</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">type-list</span><span class="p">)</span>
	<span class="nv">res</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">type-list</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">try-coercion</span>
	     <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">)</span>
	     <span class="p">(</span><span class="nb">cdr </span><span class="nv">type-list</span><span class="p">)</span>
	     <span class="nv">target-type</span>
	     <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)</span> <span class="nv">res</span><span class="p">))</span>
	    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">t2-&gt;t1</span> <span class="p">(</span><span class="nf">get-coercion</span> <span class="p">(</span><span class="nb">car </span><span class="nv">type-list</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)))</span>
	      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">t2-&gt;t1</span><span class="p">)</span>
		  <span class="nv">false</span>
		  <span class="p">(</span><span class="nf">try-coercion</span>
		   <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">)</span>
		   <span class="p">(</span><span class="nb">cdr </span><span class="nv">type-list</span><span class="p">)</span>
		   <span class="nv">target-type</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">t2-&gt;t1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">))</span> <span class="nv">res</span><span class="p">)))))))</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">cdr-type-tags</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">else</span>
	 <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-args</span> <span class="p">(</span><span class="nf">try-coercion</span> <span class="nv">args</span> <span class="nv">type-tags</span> <span class="p">(</span><span class="nb">car </span><span class="nv">cdr-type-tags</span><span class="p">)</span> <span class="o">'</span><span class="p">())))</span>
	   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">mapped-args</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">map-args</span> <span class="nv">args</span> <span class="nv">type-tags</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">cdr-type-tags</span><span class="p">))</span>
	       <span class="nv">mapped-args</span><span class="p">)))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">proc</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-args</span> <span class="p">(</span><span class="nf">map-args</span> <span class="nv">args</span> <span class="nv">type-tags</span> <span class="nv">type-tags</span><span class="p">)))</span>
	    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">mapped-args</span><span class="p">)</span>
		<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span> <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
		<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">mapped-args</span><span class="p">)))</span>
		  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">mapped-type-tags</span><span class="p">)))</span>
		    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">proc</span><span class="p">)</span>
			<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span> <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
			<span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">mapped-args</span><span class="p">)))))))</span>
	  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
	  <span class="p">))))</span>

<span class="p">(</span><span class="nf">get</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span> <span class="nv">complex</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="nf">add</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgcf942c2" class="outline-2">
<h2 id="orgcf942c2">Упражнение 2.83</h2>
<div class="outline-text-2" id="text-orgcf942c2">
<p>
Предположим вы разрабатываете систему для работы с башней типов как на картинке
</p>

<p>
<img src="images/ch2-Z-G-66.gif" alt="nil"></p>

<p>
Для каждого типа (за исключением комплексного), напишите процедуру которая поднимает тип на один уровень. Покажите как установить общую операцию raise,которая будет работать для всех типов, кроме комплексного.
</p>

<p>
если мы добавим метод raise в пакеты для scheme-number, rational, complex, тогда мы потеряем возможность разрабатывать пакеты отдельно, поэтому лучше реализовать метод через отдельную функцию.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-raise-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-rational</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'rational</span><span class="p">)</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">get</span> <span class="ss">'make-from-real-imag</span> <span class="ss">'complex</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-real</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'scheme-real</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
  <span class="c1">;; interface</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-real</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-real</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"complex can't raise"</span><span class="p">)))</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-raise-package</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">raise</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'raise</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nf">make-number</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org625b917" class="outline-2">
<h2 id="org625b917">Упражнение 2.84</h2>
<div class="outline-text-2" id="text-org625b917">
<p>
Используя процедуру raise из задачи 2.83 переделайте процедуру apply-generic, чтобы она приводила аргументы методом повышения типов.
Вам нужно придумать способ определить какой из двух типов выше в иерархии.
</p>
<div class="highlight"><pre><span></span><span class="c1">;; табличка с сравнением типов</span>
<span class="p">(</span><span class="k">define </span><span class="nv">*op-compare-types-table*</span> <span class="p">(</span><span class="nf">make-hash-table</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">put-type-value</span> <span class="nv">type</span> <span class="nv">value</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">hash-table/put!</span> <span class="nv">*op-compare-types-table*</span> <span class="p">(</span><span class="nb">list </span><span class="nv">type</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-type-value</span> <span class="nv">type</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">hash-table/get</span> <span class="nv">*op-compare-types-table*</span> <span class="p">(</span><span class="nb">list </span><span class="nv">type</span><span class="p">)</span> <span class="no">#f</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-compare-types-package</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">put-type-value</span> <span class="ss">'scheme-number</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">put-type-value</span> <span class="ss">'rational</span> <span class="mi">5</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">put-type-value</span> <span class="ss">'scheme-real</span> <span class="mi">10</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">put-type-value</span> <span class="ss">'complex</span> <span class="mi">15</span><span class="p">)</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-compare-types-package</span><span class="p">)</span>

<span class="c1">;; процедура сравнения типов</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">type1&gt;type2</span> <span class="nv">type1</span> <span class="nv">type2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">value1</span> <span class="p">(</span><span class="nf">get-type-value</span> <span class="nv">type1</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">value2</span> <span class="p">(</span><span class="nf">get-type-value</span> <span class="nv">type2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">&gt; </span><span class="nv">value1</span> <span class="nv">value2</span><span class="p">)))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">map-args</span> <span class="nv">args</span> <span class="nv">type-tags</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">find-max-value-type</span> <span class="nv">types</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-types</span> <span class="nv">types</span> <span class="nv">value</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">types</span><span class="p">)</span>
	  <span class="nv">value</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">type1&gt;type2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">types</span><span class="p">)</span> <span class="nv">value</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-types</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">types</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">types</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">iter-types</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">types</span><span class="p">)</span> <span class="nv">value</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">iter-types</span> <span class="nv">types</span> <span class="p">(</span><span class="nb">car </span><span class="nv">types</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">raise-until-type</span> <span class="nv">arg</span> <span class="nv">target-type</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nf">type-tag</span> <span class="nv">arg</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)</span>
	<span class="nv">arg</span>
	<span class="p">(</span><span class="nf">raise-until-type</span> <span class="p">(</span><span class="nf">raise</span> <span class="nv">arg</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">try-coercion</span> <span class="nv">args</span> <span class="nv">type-list</span> <span class="nv">target-type</span> <span class="nv">res</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">args</span><span class="p">)</span>
	<span class="nv">res</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">type-list</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">try-coercion</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">type-list</span><span class="p">)</span> <span class="nv">target-type</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)</span> <span class="nv">res</span><span class="p">))</span>
	    <span class="p">(</span><span class="nf">try-coercion</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">args</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">type-list</span><span class="p">)</span> <span class="nv">target-type</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">raise-until-type</span> <span class="p">(</span><span class="nb">car </span><span class="nv">args</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)</span> <span class="nv">res</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">target-type</span> <span class="p">(</span><span class="nf">find-max-value-type</span> <span class="nv">type-tags</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-args</span> <span class="p">(</span><span class="nf">try-coercion</span> <span class="nv">args</span> <span class="nv">type-tags</span> <span class="nv">target-type</span> <span class="o">'</span><span class="p">())))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">mapped-args</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">error</span> <span class="s">"No coercion for these types"</span><span class="p">)</span>
	  <span class="nv">mapped-args</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">proc</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-args</span> <span class="p">(</span><span class="nf">map-args</span> <span class="nv">args</span> <span class="nv">type-tags</span><span class="p">)))</span>
	    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">mapped-args</span><span class="p">)</span>
		<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span> <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
		<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">mapped-args</span><span class="p">)))</span>
		  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">mapped-type-tags</span><span class="p">)))</span>
		    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">proc</span><span class="p">)</span>
			<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span> <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
			<span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">mapped-args</span><span class="p">)))))))</span>
	  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
	  <span class="p">))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgef58eb3" class="outline-2">
<h2 id="orgef58eb3">Упражнение 2.85</h2>
<div class="outline-text-2" id="text-orgef58eb3">
<p>
В разделе упоминалась процедура "упрощение" объекта, понижение типа насколько возможно. Составьте процедуру drop для башни типов. К примеру комплексное 1.5 + 0i может быть сведено к типу real 1.5. И используя drop перепишите apply-generic процедуру что бы "упростить" результат.
</p>

<p>
процедура drop:
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-coercion-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-rational</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'rational</span><span class="p">)</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">get</span> <span class="ss">'make-from-real-imag</span> <span class="ss">'complex</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-real</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'scheme-real</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
  <span class="c1">;; interface</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-number</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-real</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-real</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">error</span> <span class="s">"complex can't raise"</span><span class="p">)))</span>
  <span class="c1">;; project</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'project</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-number</span> <span class="p">(</span><span class="nb">round </span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'project</span> <span class="o">'</span><span class="p">(</span><span class="nv">scheme-real</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-number</span> <span class="p">(</span><span class="nb">round </span><span class="nv">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'project</span> <span class="o">'</span><span class="p">(</span><span class="nv">complex</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-real</span> <span class="p">(</span><span class="nb">real-part </span><span class="nv">x</span><span class="p">))))</span>
  <span class="ss">'done</span><span class="p">)</span>

<span class="p">(</span><span class="nf">install-coercion-package</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">proc</span>
	  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">error</span>
	    <span class="s">"No method for these types -- APPLY-GENERIC"</span>
	    <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">real-part </span><span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'real-part</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">imag-part </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'imag-part</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">magnitude </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'magnitude</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">angle </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'angle</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">raise</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'raise</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">project</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'project</span> <span class="nv">x</span><span class="p">))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">drop</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">raise-until-type</span> <span class="nv">arg</span> <span class="nv">target-type</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nf">type-tag</span> <span class="nv">arg</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)</span>
	<span class="nv">arg</span>
	<span class="p">(</span><span class="nf">raise-until-type</span> <span class="p">(</span><span class="nf">raise</span> <span class="nv">arg</span><span class="p">)</span> <span class="nv">target-type</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pproc</span> <span class="p">(</span><span class="nf">get</span> <span class="ss">'project</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">)))))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">pproc</span><span class="p">)</span>
	<span class="nv">x</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nf">project</span> <span class="nv">x</span><span class="p">)))</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">equ?</span> <span class="p">(</span><span class="nf">raise-until-type</span> <span class="nv">p</span> <span class="p">(</span><span class="nf">type-tag</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">x</span><span class="p">)</span>
	      <span class="nv">p</span>
	      <span class="nv">x</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">drop-max</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-before</span> <span class="p">(</span><span class="nf">type-tag</span> <span class="nv">x</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">new-value</span> <span class="p">(</span><span class="nf">drop</span> <span class="nv">x</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">type-before</span> <span class="p">(</span><span class="nf">type-tag</span> <span class="nv">new-value</span><span class="p">))</span>
	<span class="nv">x</span>
	<span class="p">(</span><span class="nf">drop-max</span> <span class="nv">new-value</span><span class="p">))))</span>
</pre></div>

<p>
нам не всегда нужно делать упрощение типов, поэтому оставим старую процедуру apply-generic для всех старых операций, а для операций add, mul, div, sub введем новую процедуру apply-generic-simplified, которая будет упрощать полученный результат.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic-simplified</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">simplified-result</span> <span class="nv">res</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">boolean? </span><span class="nv">res</span><span class="p">)</span> <span class="nv">res</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">drop-max</span> <span class="nv">res</span><span class="p">))))</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">type-tags</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">proc</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-args</span> <span class="p">(</span><span class="nf">map-args</span> <span class="nv">args</span> <span class="nv">type-tags</span><span class="p">)))</span>
	    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">mapped-args</span><span class="p">)</span>
		<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span> <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
		<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapped-type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">mapped-args</span><span class="p">)))</span>
		  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="nv">op</span> <span class="nv">mapped-type-tags</span><span class="p">)))</span>
		    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">proc</span><span class="p">)</span>
			<span class="p">(</span><span class="nf">error</span> <span class="s">"No method for these types"</span> <span class="p">(</span><span class="nb">list </span><span class="nv">op</span> <span class="nv">type-tags</span><span class="p">))</span>
			<span class="p">(</span><span class="nf">simplified-result</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">mapped-args</span><span class="p">))))))))</span>
	  <span class="p">(</span><span class="nf">simplified-result</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">args</span><span class="p">)))</span>
	  <span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic-simplified</span> <span class="ss">'add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic-simplified</span> <span class="ss">'sub</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic-simplified</span> <span class="ss">'mul</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">div</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic-simplified</span> <span class="ss">'div</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="mi">1</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; ;Value: (scheme-number . 2)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb60dc01" class="outline-2">
<h2 id="orgb60dc01">Упражнение 2.86</h2>
<div class="outline-text-2" id="text-orgb60dc01">
<p>
Предположим мы хотим работать с комплексными числами, где реальная и мнимая часть могут быть представлены как обычными так и рациональными числами. Опишите и реализуйте изменения которые необходимы для этого. Вам потребуется реализовать операции sin, cos как общие операции над обычными и рациональными числами.
</p>

<p>
для этого операции +/-/*///sin/cos в пакете с комплексными нужно заменить на общие операции.
</p>

<p>
операции sin, cos, sqrt, atan чаще всего это реальный числа, поэтому напишем для них общую операцию которая будет приводить их аргумент к реальному типу данных, а затем выполнять операцию, таким образом нам не нужно будет вносить изменения во все пакеты, а только заменить эти операции в пакете для полярной и декартовой системы хранения комплексных чисел.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">operation-with-raise-to-real</span> <span class="nv">op</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'scheme-real</span> <span class="nv">z</span><span class="p">))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nf">type-tag</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">'rational</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">operation-with-raise-to-real</span> <span class="nv">op</span> <span class="p">(</span><span class="nf">raise</span> <span class="nv">x</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">op</span> <span class="p">(</span><span class="nf">contents</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">gsqrt</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">operation-with-raise-to-real</span> <span class="nv">sqrt</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cosine</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">operation-with-raise-to-real</span> <span class="nv">cos</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sine</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">operation-with-raise-to-real</span> <span class="nv">sin</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">atangens</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">operation-with-raise-to-real</span> <span class="nv">atan</span> <span class="nv">x</span><span class="p">))</span>

<span class="c1">;; в пакетах complex, polar, rectangular заменяем +-sin и так далее на общие операции</span>
<span class="c1">;; (define (install-rectangular-package)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">magnitude </span><span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">gsqrt</span> <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nb">real-part </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">real-part </span><span class="nv">z</span><span class="p">))</span>
		      <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nb">imag-part </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">imag-part </span><span class="nv">z</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">angle </span><span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">atangens</span> <span class="p">(</span><span class="nf">div</span> <span class="p">(</span><span class="nb">imag-part </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">real-part </span><span class="nv">z</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-from-mag-ang</span> <span class="nv">r</span> <span class="nv">a</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">mul</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">sine</span> <span class="nv">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">mul</span> <span class="nv">r</span> <span class="p">(</span><span class="nf">sine</span> <span class="nv">a</span><span class="p">))))</span>

<span class="c1">;;  (define (install-polar-package)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">real-part </span><span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nb">magnitude </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">cosine</span> <span class="p">(</span><span class="nb">angle </span><span class="nv">z</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">imag-part </span><span class="nv">z</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nb">magnitude </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">sine</span> <span class="p">(</span><span class="nb">angle </span><span class="nv">z</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">gsqrt</span> <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">mul</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">mul</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nb">atan </span><span class="p">(</span><span class="nf">div</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">))))</span>
<span class="c1">;; (install-polar-package)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">complex1</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">complex2</span> <span class="p">(</span><span class="nf">make-complex-from-real-imag</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">complex1</span> <span class="nv">complex2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mul</span> <span class="nv">complex1</span> <span class="nv">complex2</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgf43679a" class="outline-2">
<h2 id="orgf43679a">Упражнение 2.87</h2>
<div class="outline-text-2" id="text-orgf43679a">
<p>
Добавьте =zero? для полиномов. 
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">all-zero?</span> <span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
	  <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">coeff</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">)))</span> <span class="p">(</span><span class="nf">all-zero?</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)))</span> <span class="nv">true</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">all-zero?</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">pol1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pol2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mul</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7a7de18" class="outline-2">
<h2 id="org7a7de18">Упражнение 2.88</h2>
<div class="outline-text-2" id="text-org7a7de18">
<p>
Добавить в систему вычитание полиномов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">negation-term-list</span> <span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span>
	<span class="nv">L1</span>
	<span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">make-term</span> <span class="p">(</span><span class="nf">order</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))</span> <span class="p">(</span><span class="nf">negation</span> <span class="p">(</span><span class="nf">coeff</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))))</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'sub</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span> <span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">add-poly</span> <span class="nv">p1</span> <span class="p">(</span><span class="nf">contents</span> <span class="p">(</span><span class="nf">negation</span> <span class="p">(</span><span class="nf">tag</span> <span class="nv">p2</span><span class="p">)))))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'negation</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">make-poly</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">negation</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'negation</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'sub</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">pol1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pol2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">pol1</span> <span class="p">(</span><span class="nf">negation</span> <span class="nv">pol2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">sub</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
<span class="c1">;; Value (polinomial x)</span>
</pre></div>
</div>
</div>


<div id="outline-container-org364830b" class="outline-2">
<h2 id="org364830b">Упражнение 2.89</h2>
<div class="outline-text-2" id="text-org364830b">
<p>
Определите процедуру которая определяет представление term-list для компактных полиномов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-polynomial-dense-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'dense</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span> <span class="o">'</span><span class="p">())</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">first-term</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="c1">;; (define (make-term order coeff) (list order coeff))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">first-coeff</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">first-order</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">length </span><span class="nv">term-list</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">negation-term-list</span> <span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span>
	<span class="nv">L1</span>
	<span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">negation</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">L2</span><span class="p">)</span>
	    <span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L2</span><span class="p">)</span> <span class="nv">L1</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">else</span>
	     <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">)</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L2</span><span class="p">))</span> <span class="p">(</span><span class="nf">sum-terms</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L2</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nf">sum-terms</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">L1</span><span class="p">)</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">L2</span><span class="p">))))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">add-terms</span> <span class="p">(</span><span class="nf">mul-term-by-all-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">mul-terms</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">L2</span><span class="p">))))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-term-by-all-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-coeff</span> <span class="nv">L</span> <span class="nv">constant</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">first-term</span> <span class="nv">L</span><span class="p">)</span> <span class="nv">constant</span><span class="p">)</span> <span class="p">(</span><span class="nf">mul-coeff</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L</span><span class="p">)</span> <span class="nv">constant</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">create-n-zeroes</span> <span class="nv">n</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">cons </span><span class="mi">0</span> <span class="p">(</span><span class="nf">create-n-zeroes</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>
	  <span class="o">'</span><span class="p">()))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L2</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">coeff</span> <span class="p">(</span><span class="nf">first-coeff</span> <span class="nv">L1</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">order</span> <span class="p">(</span><span class="nf">first-order</span> <span class="nv">L1</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nf">mul-coeff</span> <span class="nv">L2</span> <span class="nv">coeff</span><span class="p">)</span> <span class="p">(</span><span class="nf">create-n-zeroes</span> <span class="nv">order</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">all-zero?</span> <span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
	  <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))</span> <span class="p">(</span><span class="nf">all-zero?</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)))</span> <span class="nv">true</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="nv">false</span><span class="p">)))</span>

  <span class="p">(</span><span class="nf">put</span> <span class="ss">'negation</span> <span class="o">'</span><span class="p">(</span><span class="nv">dense</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="nv">p</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'make</span> <span class="ss">'dense</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="nv">terms</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">dense</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms</span><span class="p">)</span> <span class="p">(</span><span class="nf">all-zero?</span> <span class="nv">terms</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">dense</span> <span class="nv">dense</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms1</span> <span class="nv">terms2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">add-terms</span> <span class="nv">terms1</span> <span class="nv">terms2</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'mul</span> <span class="o">'</span><span class="p">(</span><span class="nv">dense</span> <span class="nv">dense</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms1</span> <span class="nv">terms2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">mul-terms</span> <span class="nv">terms1</span> <span class="nv">terms2</span><span class="p">))))</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-polynomial-dense-package</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-dense-terms</span> <span class="nv">terms</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'dense</span><span class="p">)</span> <span class="nv">terms</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">dense-terms</span> <span class="p">(</span><span class="nf">make-dense-terms</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>
<span class="nv">dense-terms</span>
<span class="p">((</span><span class="nf">get</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">dense</span> <span class="nv">dense</span><span class="p">))</span> <span class="o">'</span><span class="p">(</span><span class="mi">3</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="o">'</span><span class="p">(</span><span class="mi">3</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">dense-terms</span> <span class="nv">dense-terms</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mul</span> <span class="nv">dense-terms</span> <span class="nv">dense-terms</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgfdc03bf" class="outline-2">
<h2 id="orgfdc03bf">Упражнение 2.90</h2>
<div class="outline-text-2" id="text-orgfdc03bf">
<p>
Предположим бы хотим иметь два представления для компактных и разбросанных полиномов. Нам нужно разрешить два представления для полиномов. Перепишите модуль для полиномов что бы он работал с двумя представлениями.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-polynomial-sparse-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'sparse</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span> <span class="o">'</span><span class="p">())</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">first-term</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">term-list</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-term</span> <span class="nv">order</span> <span class="nv">coeff</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">order</span> <span class="nv">coeff</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">order</span> <span class="nv">term</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">term</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">coeff</span> <span class="nv">term</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">term</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">negation-term-list</span> <span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span>
	<span class="nv">L1</span>
	<span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">make-term</span> <span class="p">(</span><span class="nf">order</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))</span> <span class="p">(</span><span class="nf">negation</span> <span class="p">(</span><span class="nf">coeff</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))))</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-term</span> <span class="nv">term</span> <span class="nv">term-list</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">term</span><span class="p">))</span>
	<span class="nv">term-list</span>
	<span class="p">(</span><span class="nb">cons </span><span class="nv">term</span> <span class="nv">term-list</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">L2</span><span class="p">)</span>
	  <span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L2</span><span class="p">)</span> <span class="nv">L1</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">else</span>
	   <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">t1</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))</span> <span class="p">(</span><span class="nf">t2</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L2</span><span class="p">)))</span>
	     <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">order</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">order</span> <span class="nv">t2</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">adjoin-term</span>
		     <span class="nv">t1</span> <span class="p">(</span><span class="nf">add-terms</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">L2</span><span class="p">)))</span>
		   <span class="p">((</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">order</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">order</span> <span class="nv">t2</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">adjoin-term</span>
		     <span class="nv">t2</span> <span class="p">(</span><span class="nf">add-terms</span> <span class="nv">L1</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L2</span><span class="p">))))</span>
		   <span class="p">(</span><span class="nf">else</span>
		    <span class="p">(</span><span class="nf">adjoin-term</span>
		     <span class="p">(</span><span class="nf">make-term</span> <span class="p">(</span><span class="nf">order</span> <span class="nv">t1</span><span class="p">)</span>
				<span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">t2</span><span class="p">)))</span>
		     <span class="p">(</span><span class="nf">add-terms</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)</span>
				<span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L2</span><span class="p">)))))))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">add-terms</span> <span class="p">(</span><span class="nf">mul-term-by-all-terms</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">L2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">mul-terms</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">L2</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-term-by-all-terms</span> <span class="nv">t1</span> <span class="nv">L</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">t2</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nf">adjoin-term</span>
	   <span class="p">(</span><span class="nf">make-term</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">order</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">order</span> <span class="nv">t2</span><span class="p">))</span>
		      <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">t2</span><span class="p">)))</span>
	   <span class="p">(</span><span class="nf">mul-term-by-all-terms</span> <span class="nv">t1</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L</span><span class="p">))))))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">all-zero?</span> <span class="nv">L1</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
	  <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">coeff</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">)))</span> <span class="p">(</span><span class="nf">all-zero?</span> <span class="p">(</span><span class="nf">rest-terms</span> <span class="nv">L1</span><span class="p">)))</span> <span class="nv">true</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">else </span><span class="nv">false</span><span class="p">)))</span>

  <span class="p">(</span><span class="nf">put</span> <span class="ss">'negation</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="nv">p</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'make</span> <span class="ss">'sparse</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="nv">terms</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms</span><span class="p">)</span> <span class="p">(</span><span class="nf">all-zero?</span> <span class="nv">terms</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span> <span class="nv">sparse</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms1</span> <span class="nv">terms2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">add-terms</span> <span class="nv">terms1</span> <span class="nv">terms2</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'mul</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span> <span class="nv">sparse</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms1</span> <span class="nv">terms2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">mul-terms</span> <span class="nv">terms1</span> <span class="nv">terms2</span><span class="p">))))</span>
  <span class="ss">'done</span><span class="p">)</span>

<span class="p">(</span><span class="nf">install-polynomial-sparse-package</span><span class="p">)</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'add-terms</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparce</span> <span class="nv">sparce</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'mul</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sparce-terms</span> <span class="nv">terms</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'sparse</span><span class="p">)</span> <span class="nv">terms</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">sparce-terms</span> <span class="p">(</span><span class="nf">make-sparce-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
<span class="nv">sparce-terms</span>
<span class="p">((</span><span class="nf">get</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span> <span class="nv">sparse</span><span class="p">))</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">sparce-terms</span> <span class="nv">sparce-terms</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mul</span> <span class="nv">sparce-terms</span> <span class="nv">sparce-terms</span><span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-polynomial-package</span><span class="p">)</span>
  <span class="c1">;; internal procedures</span>
  <span class="c1">;; representation of poly</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-poly</span> <span class="nv">variable</span> <span class="nv">term-list</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="nv">variable</span> <span class="nv">term-list</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">variable</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">term-list</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">p</span><span class="p">))</span>
  <span class="c1">;; &lt;procedures same-variable? and variable? from section 2.3.2&gt;</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol? </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable?</span> <span class="nv">v2</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">)))</span>
  <span class="c1">;; representation of terms and term lists</span>
  <span class="c1">;; ((100 1) (2 2) (0 1)) = x^100 + 2x^2 + 1</span>

  <span class="c1">;; procedurs on poly</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">term-list</span> <span class="nv">p1</span><span class="p">))</span>

    <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">term-list</span> <span class="nv">p2</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p2</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">make-poly</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p1</span><span class="p">)</span>
			<span class="p">(</span><span class="nf">term-list</span> <span class="nv">p2</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">error</span> <span class="s">"Polys not in same var -- ADD-POLY"</span>
	       <span class="p">(</span><span class="nb">list </span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p2</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">make-poly</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p1</span><span class="p">)</span>
			<span class="p">(</span><span class="nf">term-list</span> <span class="nv">p2</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">error</span> <span class="s">"Polys not in same var -- MUL-POLY"</span>
	       <span class="p">(</span><span class="nb">list </span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>

  <span class="c1">;; interface to rest of the system</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'polynomial</span> <span class="nv">p</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span> <span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">add-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'sub</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span> <span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">add-poly</span> <span class="nv">p1</span> <span class="p">(</span><span class="nf">contents</span> <span class="p">(</span><span class="nf">negation</span> <span class="p">(</span><span class="nf">tag</span> <span class="nv">p2</span><span class="p">)))))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'mul</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span> <span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">mul-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'make</span> <span class="ss">'polynomial</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">var</span> <span class="nv">terms</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">make-poly</span> <span class="nv">var</span> <span class="nv">terms</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'negation</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">make-poly</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">negation</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p</span><span class="p">))))))</span>
  <span class="ss">'done</span><span class="p">)</span>

<span class="p">(</span><span class="nf">install-polynomial-package</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">pol1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pol2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">negation</span> <span class="nv">pol2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">pol1</span> <span class="p">(</span><span class="nf">negation</span> <span class="nv">pol2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">sub</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mul</span> <span class="nv">pol1</span> <span class="nv">pol2</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-orge3eaf8d" class="outline-2">
<h2 id="orge3eaf8d">Упражнение 2.91</h2>
<div class="outline-text-2" id="text-orge3eaf8d">
<p>
Допишите функцию деления полиномов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">add-terms</span> <span class="nv">L1</span> <span class="p">(</span><span class="nf">negation-term-list</span> <span class="nv">L2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">L1</span> <span class="nv">L2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">L1</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span> <span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">))</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">t1</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L1</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">t2</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">L2</span><span class="p">)))</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">order</span> <span class="nv">t2</span><span class="p">)</span> <span class="p">(</span><span class="nf">order</span> <span class="nv">t1</span><span class="p">))</span>
	      <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">the-empty-termlist</span><span class="p">)</span> <span class="nv">L1</span><span class="p">)</span>
	      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">new-c</span> <span class="p">(</span><span class="nf">div</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">t2</span><span class="p">)))</span>
		    <span class="p">(</span><span class="nf">new-o</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">order</span> <span class="nv">t1</span><span class="p">)</span> <span class="p">(</span><span class="nf">order</span> <span class="nv">t2</span><span class="p">))))</span>
		<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rest-of-result</span>
		       <span class="p">(</span><span class="nf">sub-terms</span> <span class="nv">L1</span> <span class="p">(</span><span class="nf">mul-terms</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-term</span> <span class="nv">new-o</span> <span class="nv">new-c</span><span class="p">))</span> <span class="nv">L2</span><span class="p">))))</span>

		  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">result</span> <span class="p">(</span><span class="nf">div-terms</span> <span class="nv">rest-of-result</span> <span class="nv">L2</span><span class="p">)))</span>
		    <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">add-terms</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-term</span> <span class="nv">new-o</span> <span class="nv">new-c</span><span class="p">))</span> <span class="p">(</span><span class="nb">car </span><span class="nv">result</span><span class="p">))</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">result</span><span class="p">)))))))))</span>
</pre></div>
</div>
</div>


<div id="outline-container-orga325370" class="outline-2">
<h2 id="orga325370">Упражнение 2.92</h2>
<div class="outline-text-2" id="text-orga325370">
<p>
Задав приоритет переменным, дополните пакет работы с полиномами так чтобы сумма и умножение для полиномов работало для полиномов разных переменных.
</p>

<p>
Нужно научиться приводить полином по x к полиному по y. Тогда мы сможем сложить полином по x c полиномом по y, приведя их к одной переменной.
</p>

<p>
например вот такой полином, будет очевидно равен сумме полиномов, то есть достаточно научиться приводить первую часть, а потом взять сумму от этого.
x<sup>2</sup> (3y<sup>2</sup> + 2) + x (y<sup>3</sup> + 2y<sup>2</sup> + 3)
смотрим
x<sup>2</sup> (3y<sup>2</sup> + 2) + …
x<sup>2</sup> 3y<sup>2</sup> + x<sup>2</sup> 2
y<sup>2</sup> (x<sup>2</sup>)3 + y<sup>0</sup>(x<sup>2</sup>)2
</p>

<p>
'y (2 (p (2 3)) (0 (p (2 2))
такой полином можем привести к полиному по y, все порядки y остаются прежними, а коэффициенты, это полином, по x<sup>2</sup> умноженный на прежний коэффициенты y.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-coercion-polynomial-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'polynomial</span> <span class="nv">p</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">term-list</span> <span class="nv">pol</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">pol</span><span class="p">)))</span>
    <span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">order</span> <span class="nv">term</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">term</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">coeff</span> <span class="nv">term</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">term</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">switch-variable</span> <span class="nv">pol</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">switch-single-term</span> <span class="nv">single</span><span class="p">)</span>
      <span class="c1">;; term here y and polinom x</span>
      <span class="p">(</span>
       <span class="nv">make-polynomial</span>
       <span class="ss">'x</span>
       <span class="p">(</span><span class="nf">make-sparse-terms</span>
	<span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">term</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">list</span>
		<span class="p">(</span><span class="nf">order</span> <span class="nv">term</span><span class="p">)</span>
		<span class="p">(</span><span class="nf">make-polynomial</span>
		 <span class="ss">'y</span>
		 <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">car </span><span class="nv">single</span><span class="p">)</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">term</span><span class="p">))))</span>
		 <span class="p">)))</span>
	     <span class="p">(</span><span class="nb">cadr </span><span class="nv">single</span><span class="p">)))))</span>

    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-list</span> <span class="nv">l</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">l</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nb">car </span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">l</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nb">car </span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-list</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">l</span><span class="p">)))))</span>

    <span class="c1">;; пусть пока везде полиномы, в общем виде надо добавить условие</span>
    <span class="c1">;; приведения числа к полиному.</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mapterms</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">term</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">term</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">term-list</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">term</span><span class="p">)))))</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">pol</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">sum-list</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">item</span><span class="p">)</span> <span class="p">(</span><span class="nf">switch-single-term</span> <span class="nv">item</span><span class="p">))</span> <span class="nv">mapterms</span><span class="p">))</span>
      <span class="p">)</span>
    <span class="p">)</span>
  <span class="c1">;; interface</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'raise</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pol</span><span class="p">)</span> <span class="p">(</span><span class="nf">switch-variable</span> <span class="p">(</span><span class="nf">tag</span> <span class="nv">pol</span><span class="p">))))</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-coercion-polynomial-package</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">pol2variable</span> <span class="p">(</span><span class="nf">make-polynomial</span>
		      <span class="ss">'y</span>
		      <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))</span>
					       <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">3</span><span class="p">)))))</span>
					       <span class="p">(</span><span class="nb">list </span><span class="mi">0</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">0</span> <span class="mi">5</span><span class="p">)))))))))</span>

<span class="nv">pol2variable</span>
<span class="p">(</span><span class="nf">raise</span> <span class="nv">pol2variable</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">pol1</span> <span class="p">(</span>
	      <span class="nv">make-polynomial</span>
	      <span class="ss">'x</span>
	      <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'y</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))</span>
				       <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'y</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))</span>
				       <span class="p">(</span><span class="nb">list </span><span class="mi">0</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'y</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))))))</span>
<span class="nv">pol1</span>
<span class="p">(</span><span class="nf">add</span> <span class="nv">pol1</span> <span class="p">(</span><span class="nf">raise</span> <span class="nv">pol2variable</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org4e64d32" class="outline-2">
<h2 id="org4e64d32">Упражнение 2.93, 2.94</h2>
<div class="outline-text-2" id="text-org4e64d32">
<p>
Измените пакет для рациональных чисел чтобы он мог работать с полиномами. Протестируйте ваш пакет, вызвав make-rational над полиномами.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-rational-polynomial-package</span><span class="p">)</span>
  <span class="c1">;; internal procedures</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-rat</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="nv">n</span> <span class="nv">d</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-rat</span> <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">))</span>
		 <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-rat</span> <span class="p">(</span><span class="nf">sub</span> <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">))</span>
		 <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mul-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-rat</span> <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">y</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">div-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-rat</span> <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">y</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">mul</span> <span class="p">(</span><span class="nf">denom</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="c1">;; interface to rest of the system</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'rational</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">real-tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="ss">'scheme-real</span> <span class="nv">x</span><span class="p">))</span>


  <span class="p">(</span><span class="nf">put</span> <span class="ss">'add</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span> <span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">add-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'sub</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span> <span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">sub-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'mul</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span> <span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">mul-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'div</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span> <span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">div-rat</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>

  <span class="p">(</span><span class="nf">put</span> <span class="ss">'make</span> <span class="ss">'rational</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">make-rat</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'=zero?</span> <span class="o">'</span><span class="p">(</span><span class="nv">rational</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">=zero?</span> <span class="p">(</span><span class="nf">numer</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-rational-polynomial-package</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-rational</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="ss">'make</span> <span class="ss">'rational</span><span class="p">)</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))</span>
</pre></div>

<p>
Теперь сложите rf с самим собой. Вы увидите что процедура добавления не сокращает деление до наименьших чисел. Напишите поиск наибольшего общего делителя для полиномов используя remainder-terms из упражнения 2.91.
</p>

<p>
Напишите процедуру нахождения НОД для полиномов и протестируйте результат.
</p>

<div class="highlight"><pre><span></span><span class="c1">;; в пакете записи полиномов</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">remainder-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">b</span><span class="p">)</span>
	<span class="nv">a</span>
	<span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">remainder-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'gcd-terms</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span> <span class="nv">sparse</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms1</span> <span class="nv">terms2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">terms1</span> <span class="nv">terms2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">term1</span> <span class="nv">term2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'gcd-terms</span> <span class="nv">term1</span> <span class="nv">term2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">gcd-terms</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">4</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">-2</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
	   <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">-1</span><span class="p">)))</span>
	   <span class="p">)</span>
<span class="c1">;;Value: (sparse (2 -1) (1 1))</span>

<span class="c1">;; в пакете для полиномов</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">gcd-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p2</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">make-poly</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">gcd-terms</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p1</span><span class="p">)</span>
			      <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p2</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">error</span> <span class="s">"Polys not in same var -- GCD-POLY"</span>
	       <span class="p">(</span><span class="nb">list </span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'greatest-common-divisor</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span> <span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">gcd-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">greatest-common-divisor</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'greatest-common-divisor</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">terms1</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">4</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">-2</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">terms2</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">-1</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="nv">terms1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="nv">terms2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">greatest-common-divisor</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
<span class="c1">;Value: (polynomial x sparse (2 -1) (1 1))</span>
</pre></div>
</div>
</div>


<div id="outline-container-org00cb686" class="outline-2">
<h2 id="org00cb686">Упражнение 2.95, 2.96, 2.97</h2>
<div class="outline-text-2" id="text-org00cb686">
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">terms1</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">-2</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="nv">terms1</span><span class="p">))</span>
<span class="nv">p1</span>
<span class="p">(</span><span class="k">define </span><span class="nv">terms2</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">11</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">7</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="nv">terms2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">terms3</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">1</span> <span class="mi">13</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">5</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p3</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="nv">terms3</span><span class="p">))</span>
<span class="nv">p2</span>
<span class="nv">p3</span>
<span class="p">(</span><span class="k">define </span><span class="nv">q1</span> <span class="p">(</span><span class="nf">mul</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))</span>
<span class="nv">q1</span>
<span class="c1">;Value: (polynomial x sparse (4 11) (3 -22) (2 18) (1 -14) (0 7))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">q2</span> <span class="p">(</span><span class="nf">mul</span> <span class="nv">p1</span> <span class="nv">p3</span><span class="p">))</span>
<span class="nv">q2</span>
<span class="c1">;Value: (polynomial x sparse (3 13) (2 -21) (1 3) (0 5))</span>
<span class="p">(</span><span class="nf">greatest-common-divisor</span> <span class="nv">q1</span> <span class="nv">q2</span><span class="p">)</span>
<span class="c1">;Value: (polynomial x sparse (2 1458/169) (1 -2916/169) (0 1458/169))</span>
</pre></div>

<p>
a. определите процедуру псевдоделения
b. измените результирующий НОД что бы исправить коэффициенты.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiple-coeffs</span> <span class="nv">q</span> <span class="nv">integer-factor</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">order</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">coeff</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">integer-factor</span><span class="p">)))</span> <span class="nv">q</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">integerizing-factor</span> <span class="nv">p</span> <span class="nv">q</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">c</span> <span class="p">(</span><span class="nf">coeff</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">q</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">o1</span> <span class="p">(</span><span class="nf">order</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">p</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">o2</span> <span class="p">(</span><span class="nf">order</span> <span class="p">(</span><span class="nf">first-term</span> <span class="nv">q</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">expt </span><span class="nv">c</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">o1</span> <span class="p">(</span><span class="nb">- </span><span class="nv">o2</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">remainder-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pseudoremainder-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">ma</span> <span class="p">(</span><span class="nf">multiple-coeffs</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">integerizing-factor</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">ma</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">reduce-gcd-terms-coeff</span> <span class="nv">terms</span><span class="p">)</span>

  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">gcd-integer-list</span> <span class="nv">l</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">l</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">car </span><span class="nv">l</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">gcd-integer-list</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">gcd </span><span class="p">(</span><span class="nb">car </span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">l</span><span class="p">))</span> <span class="p">(</span><span class="nb">cddr </span><span class="nv">l</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">l</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">coeff</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">terms</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">multiple-coeffs</span> <span class="nv">terms</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">gcd-integer-list</span> <span class="nv">l</span><span class="p">))))</span>
  <span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty-termlist?</span> <span class="nv">b</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">reduce-gcd-terms-coeff</span> <span class="nv">a</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">pseudoremainder-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
</pre></div>

<p>
c. определите процедуру reduce для полиномов
</p>

<div class="highlight"><pre><span></span><span class="c1">;; в пакете рациональных полиномов</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-rat</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">red</span> <span class="p">(</span><span class="nf">reduce</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">red</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">red</span><span class="p">))))</span>
<span class="c1">;; для списков коэффициентов</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">reduce-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">gcd-ab</span> <span class="p">(</span><span class="nf">gcd-terms</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">a</span> <span class="nv">gcd-ab</span><span class="p">)))</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">div-terms</span> <span class="nv">b</span> <span class="nv">gcd-ab</span><span class="p">))))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'reduce</span> <span class="o">'</span><span class="p">(</span><span class="nv">sparse</span> <span class="nv">sparse</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms1</span> <span class="nv">terms2</span><span class="p">)</span> <span class="p">(</span><span class="nf">reduce-terms</span> <span class="nv">terms1</span> <span class="nv">terms2</span><span class="p">)))</span>
<span class="c1">;; для полиномов</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">reduce-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p2</span><span class="p">))</span>
	<span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">terms</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">make-poly</span> <span class="p">(</span><span class="nf">variable</span> <span class="nv">p1</span><span class="p">)</span> <span class="nv">terms</span><span class="p">)))</span>
	     <span class="p">(</span><span class="nf">reduce</span> <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p1</span><span class="p">)</span>
		     <span class="p">(</span><span class="nf">term-list</span> <span class="nv">p2</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">error</span> <span class="s">"Polys not in same var -- REDUCE-POLY"</span>
	       <span class="p">(</span><span class="nb">list </span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="ss">'reduce</span> <span class="o">'</span><span class="p">(</span><span class="nv">polynomial</span> <span class="nv">polynomial</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span> <span class="p">(</span><span class="nf">reduce-poly</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">reduce</span> <span class="nv">term1</span> <span class="nv">term2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'reduce</span> <span class="nv">term1</span> <span class="nv">term2</span><span class="p">))</span>


<span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span> <span class="mi">1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span> <span class="mi">-1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p3</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p4</span> <span class="p">(</span><span class="nf">make-polynomial</span> <span class="ss">'x</span> <span class="p">(</span><span class="nf">make-sparse-terms</span> <span class="o">'</span><span class="p">((</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span> <span class="mi">-1</span><span class="p">)))))</span>
<span class="nv">p1</span>
<span class="nv">p2</span>
<span class="p">(</span><span class="k">define </span><span class="nv">rf1</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">rf2</span> <span class="p">(</span><span class="nf">make-rational</span> <span class="nv">p3</span> <span class="nv">p4</span><span class="p">))</span>
<span class="nv">rf2</span>

<span class="nv">rf1</span>

<span class="p">(</span><span class="nf">add</span> <span class="nv">rf1</span> <span class="nv">rf2</span><span class="p">)</span>
<span class="c1">;Value: (rational (polynomial x sparse (3 144) (2 56) (1 90) (0 34)) polynomial x sparse (4 11) (2 -4) (0 -7))</span>
</pre></div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-24-mnozhestvennye-predstavleniia-dlia-abstraktnykh-dannykh/" class="u-url">SICP 2.4 Множественные представления для абстрактных данных.</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-24-mnozhestvennye-predstavleniia-dlia-abstraktnykh-dannykh/" rel="bookmark">
            <time class="published dt-published" datetime="2020-01-25T19:33:39+03:00" itemprop="datePublished" title="2020-01-25 19:33">2020-01-25 19:33</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>
<img src="images/ch2-Z-G-54.gif" alt="nil"></p>


<p>
<img src="images/ch2-Z-G-62.gif" alt="nil"></p>


<div id="outline-container-org3dfb9b4" class="outline-2">
<h2 id="org3dfb9b4">Упражнение 2.73</h2>
<div class="outline-text-2" id="text-org3dfb9b4">
<p>
В секции 2.3.2 описана программа символического дифференцирования.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
	<span class="p">((</span><span class="nf">sum?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">addend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">augend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
	<span class="p">((</span><span class="nf">product?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-sum</span>
	   <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
	   <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">))))</span>
	<span class="nv">&lt;more</span> <span class="nv">rules</span> <span class="nv">can</span> <span class="nv">be</span> <span class="nv">added</span> <span class="nv">here&gt;</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"unknown expression type -- DERIV"</span> <span class="nv">exp</span><span class="p">))))</span>
</pre></div>

<p>
Мы можем переписать программу что бы она выполняла дифференцирование по типу выражения. В данном случае "type tag" - символ алгебраической операции (к примеру +).
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	 <span class="p">((</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
	 <span class="p">(</span><span class="k">else </span><span class="p">((</span><span class="nf">get</span> <span class="ss">'deriv</span> <span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span>
					    <span class="nv">var</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">exp</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">exp</span><span class="p">))</span>
</pre></div>

<p>
a. Объясните что сделано выше? Почему мы не можем применить number? и same-variable? в дата ориенторованный обработчик?
</p>

<p>
number? и same-variable? не содержат знака операции поэтому они не могут быть обработаны по типу операции.
</p>

<p>
b. напишите процедуру для взятия производной от суммы и произведения и вспомогательный код который помещает их в таблицу.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">get</span> <span class="mi">2</span><span class="nv">d-get</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">put</span> <span class="mi">2</span><span class="nv">d-put!</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	 <span class="p">((</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
	 <span class="p">(</span><span class="k">else </span><span class="p">((</span><span class="nf">get</span> <span class="ss">'deriv</span> <span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span>
		<span class="nv">var</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">exp</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">exp</span><span class="p">))</span>

<span class="c1">;; для произведения</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-deriv-mul-package</span><span class="p">)</span>
  <span class="c1">;; internal procedures</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplier</span> <span class="nv">opds</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">opds</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">opds</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">opds</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'*</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv-mul</span> <span class="nv">operands</span> <span class="nv">var</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-sum</span>
     <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">operands</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">operands</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">operands</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">operands</span><span class="p">))))</span>
  <span class="c1">;; interface to the rest of the system</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'deriv</span> <span class="ss">'*</span> <span class="nv">deriv-mul</span><span class="p">)</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-deriv-mul-package</span><span class="p">)</span>
<span class="c1">;; для суммы</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-deriv-sum-package</span><span class="p">)</span>
  <span class="c1">;; internal procedures</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">opds</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">opds</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">opds</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">opds</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv-sum</span> <span class="nv">opds</span> <span class="nv">var</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">addend</span> <span class="nv">opds</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">augend</span> <span class="nv">opds</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
  <span class="c1">;; interface to the rest of the system</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'deriv</span> <span class="ss">'+</span> <span class="nv">deriv-sum</span><span class="p">)</span>
  <span class="ss">'done</span><span class="p">)</span>
<span class="p">(</span><span class="nf">install-deriv-sum-package</span><span class="p">)</span>
</pre></div>

<p>
c. добавить правило диффиренцирования для экспоненты
</p>

<div class="highlight"><pre><span></span><span class="c1">;; для экспоненты</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-deriv-exp-package</span><span class="p">)</span>
  <span class="c1">;; internal procedures</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">base</span> <span class="nv">opds</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">opds</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exponent</span> <span class="nv">opds</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">opds</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'*</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-exponentiation</span> <span class="nv">b1</span> <span class="nv">e2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">=number?</span> <span class="nv">e2</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">((</span><span class="nf">=number?</span> <span class="nv">e2</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b1</span><span class="p">)</span>
	  <span class="p">((</span><span class="nf">=number?</span> <span class="nv">b1</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">b1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">e2</span><span class="p">))</span> <span class="p">(</span><span class="nb">expt </span><span class="nv">b1</span> <span class="nv">e2</span><span class="p">))</span>
	  <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">list </span><span class="ss">'**</span> <span class="nv">b1</span> <span class="nv">e2</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv-exp</span> <span class="nv">opds</span> <span class="nv">var</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">opds</span><span class="p">)</span>
				<span class="p">(</span><span class="nf">make-exponentiation</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">opds</span><span class="p">)</span>
						     <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">opds</span><span class="p">)</span> <span class="mi">-1</span><span class="p">)))</span>
		  <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">opds</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
  <span class="c1">;; interface to the rest of the system</span>
  <span class="p">(</span><span class="nf">put</span> <span class="ss">'deriv</span> <span class="ss">'**</span> <span class="nv">deriv-exp</span><span class="p">)</span>
  <span class="ss">'done</span><span class="p">)</span>

<span class="p">(</span><span class="nf">install-deriv-exp-package</span><span class="p">)</span>
<span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">**</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>

<p>
d. предположим мы индексируем процедуры другим способом, то есть в процедуре производной вызывается вот такой код
</p>
<div class="highlight"><pre><span></span><span class="p">((</span><span class="nf">get</span> <span class="p">(</span><span class="nf">operator</span> <span class="nv">exp</span><span class="p">)</span> <span class="ss">'deriv</span><span class="p">)</span> <span class="p">(</span><span class="nf">operands</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
</pre></div>

<p>
Какие изменения необходимо сделать в остальной системе что бы код продолжал работать?
</p>

<p>
нам нужно изменить интерфейсную часть пакетов, то есть при выполнении put нужно поменять местами операнд и имя функции
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">put</span> <span class="ss">'**</span> <span class="ss">'deriv</span> <span class="nv">deriv-exp</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org3f59c89" class="outline-2">
<h2 id="org3f59c89">Упражнение 2.74</h2>
<div class="outline-text-2" id="text-org3f59c89">
<p>
"Жадное Предприятие Inc." широко децентрализованная компания, которая имеет много подразделений. В каждом подразделении своя реализация хранения списка персонала. Нужно иметь возможность получать и искать сотрудников по всем подразделениям, определите общие методы.
</p>

<p>
a. Дайте определение общей процедуры get-record, которая получает информацию по конкретному сотруднику из файла списка сотрудников подразделения.
</p>

<p>
b. Дайте определение общей процедуры get-salary, которая получает зарплату сотрудника.
</p>

<p>
c. Сделайте общую процедуру find-employee-record которая ищет по имени по всем подразделениям.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-department-1-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">TYPE</span> <span class="ss">'department1</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">allemployees</span> <span class="p">(</span><span class="nb">list </span><span class="o">'</span><span class="p">(</span><span class="nv">Каблуков</span> <span class="mf">100.0</span> <span class="s">"Достоевского 5, кв. 20"</span> <span class="mi">1</span><span class="p">)</span>
			     <span class="o">'</span><span class="p">(</span><span class="nv">Коровин</span> <span class="mf">70.0</span> <span class="s">"Луговая 2"</span> <span class="mi">2</span><span class="p">)</span>
			     <span class="o">'</span><span class="p">(</span><span class="nv">Тихонов</span> <span class="mf">75.0</span> <span class="s">"Лунина 13, кв. 156"</span> <span class="mi">3</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">last-name</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">car </span><span class="nv">record</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">salary</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cadr </span><span class="nv">record</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">address</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">caddr </span><span class="nv">record</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">id</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cadddr </span><span class="nv">record</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-record</span> <span class="nv">employee-id</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-search</span> <span class="nv">pk</span> <span class="nv">records</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">records</span><span class="p">)</span>
	  <span class="nv">false</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">pk</span> <span class="p">(</span><span class="nf">id</span> <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">pk</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">records</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">employee-id</span> <span class="nv">allemployees</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">search-by-name</span> <span class="nv">employee-name</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-search</span> <span class="nv">name</span> <span class="nv">records</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">records</span><span class="p">)</span>
	  <span class="nv">false</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">name</span> <span class="p">(</span><span class="nf">last-name</span> <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">records</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">employee-name</span> <span class="nv">allemployees</span><span class="p">))</span>
  <span class="c1">;; interface</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="nv">TYPE</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'get-record</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">get-record</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'get-salary</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rec</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">salary</span> <span class="nv">rec</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'find-employee-record</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">search-by-name</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="nv">TYPE</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">dp1</span> <span class="p">(</span><span class="nf">install-department-1-package</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">install-department-2-package</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">TYPE</span> <span class="ss">'department2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="nv">allemployees</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="mi">4</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'Щавелев</span> <span class="mf">105.0</span> <span class="s">"Пушкина 5, кв. 20"</span><span class="p">))</span>
			     <span class="p">(</span><span class="nb">list </span><span class="mi">5</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'Коровин</span> <span class="mf">71.0</span> <span class="s">"Пушкина 2"</span><span class="p">))</span>
			     <span class="p">(</span><span class="nb">list </span><span class="mi">6</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'Куравлев</span> <span class="mf">74.0</span> <span class="s">"Лунина 13, кв. 156"</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">last-name</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">record</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">salary</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">record</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">address</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">caddr </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">record</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">id</span> <span class="nv">record</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">car </span><span class="nv">record</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-record</span> <span class="nv">employee-id</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-search</span> <span class="nv">pk</span> <span class="nv">records</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">records</span><span class="p">)</span>
	  <span class="nv">false</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">pk</span> <span class="p">(</span><span class="nf">id</span> <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nb">car </span><span class="nv">records</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">pk</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">records</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">employee-id</span> <span class="nv">allemployees</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">search-by-name</span> <span class="nv">employee-name</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-search</span> <span class="nv">name</span> <span class="nv">employees</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">employees</span><span class="p">)</span>
	  <span class="nv">false</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">name</span> <span class="p">(</span><span class="nf">last-name</span> <span class="p">(</span><span class="nb">car </span><span class="nv">employees</span><span class="p">)))</span>
	      <span class="p">(</span><span class="nb">car </span><span class="nv">employees</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">employees</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">iter-search</span> <span class="nv">employee-name</span> <span class="nv">allemployees</span><span class="p">))</span>
  <span class="c1">;; interface</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tag</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">attach-tag</span> <span class="nv">TYPE</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'get-record</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">get-record</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'get-salary</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rec</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">salary</span> <span class="nv">rec</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'find-employee-record</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="nf">search-by-name</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="nv">TYPE</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">dp2</span> <span class="p">(</span><span class="nf">install-department-2-package</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-record</span> <span class="nv">employee-id</span> <span class="nv">department-id</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">get</span> <span class="nv">department-id</span> <span class="ss">'get-record</span><span class="p">)</span> <span class="nv">employee-id</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="o">.</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">type-tags</span> <span class="p">(</span><span class="nb">map </span><span class="nv">type-tag</span> <span class="nv">args</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">proc</span> <span class="p">(</span><span class="nf">get</span> <span class="p">(</span><span class="nb">car </span><span class="nv">type-tags</span><span class="p">)</span> <span class="nv">op</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if </span><span class="nv">proc</span>
	  <span class="p">(</span><span class="nb">apply </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">map </span><span class="nv">contents</span> <span class="nv">args</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">error</span>
	    <span class="s">"No method for these types -- APPLY-GENERIC"</span>
	    <span class="p">(</span><span class="nb">list </span><span class="nv">type-tags</span> <span class="nv">op</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">get-salary</span> <span class="nv">record</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'get-salary</span> <span class="nv">record</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">find-employee-record</span> <span class="nv">employee-name</span> <span class="nv">deps</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-department-search</span> <span class="nv">name</span> <span class="nv">deps</span> <span class="nv">res</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">deps</span><span class="p">))</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">record</span> <span class="p">((</span><span class="nf">get</span> <span class="p">(</span><span class="nb">car </span><span class="nv">deps</span><span class="p">)</span> <span class="ss">'find-employee-record</span><span class="p">)</span> <span class="nv">name</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nb">display </span><span class="nv">record</span><span class="p">)</span>
	  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="nv">record</span> <span class="nv">false</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-department-search</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">deps</span><span class="p">)</span> <span class="nv">res</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">iter-department-search</span> <span class="nv">name</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">deps</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">record</span> <span class="nv">res</span><span class="p">)))))</span>
    <span class="nv">res</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">iter-department-search</span> <span class="nv">employee-name</span> <span class="nv">deps</span> <span class="o">'</span><span class="p">()))</span>
<span class="nv">dp1</span>
<span class="nv">dp2</span>
<span class="p">(</span><span class="nb">equal? </span><span class="ss">'Li</span> <span class="ss">'Li</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get</span> <span class="nv">dp2</span> <span class="ss">'find-employee-record</span><span class="p">)</span>
<span class="p">((</span><span class="nf">get</span> <span class="nv">dp2</span> <span class="ss">'find-employee-record</span><span class="p">)</span> <span class="ss">'Li</span><span class="p">)</span>
<span class="p">(</span><span class="nf">find-employee-record</span> <span class="ss">'Коровин</span> <span class="p">(</span><span class="nb">list </span><span class="nv">dp1</span> <span class="nv">dp2</span><span class="p">))</span>
</pre></div>

<p>
d. Какие изменения нужно внести если в Жадное Предприятие Inc. добавится еще одна дочерняя.
</p>

<p>
При добавлении подразделения нужно будет задать уникальный TYPE и реализовать интерфейс.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'get-record</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="o">...</span> <span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'get-salary</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rec</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="o">...</span> <span class="nv">rec</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">put</span> <span class="nv">TYPE</span> <span class="ss">'find-employee-record</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">tag</span> <span class="p">(</span><span class="o">...</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7e3d48a" class="outline-2">
<h2 id="org7e3d48a">Упражнение 2.75</h2>
<div class="outline-text-2" id="text-org7e3d48a">
<p>
Определите конструктор make-from-mag-ang в стиле получения сообщения (message-passing).
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-from-real-imag</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">op</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'real-part</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'imag-part</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'magnitude</span><span class="p">)</span>
	   <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">y</span><span class="p">))))</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'angle</span><span class="p">)</span> <span class="p">(</span><span class="nb">atan </span><span class="nv">y</span> <span class="nv">x</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">else</span>
	   <span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown op -- MAKE-FROM-REAL-IMAG"</span> <span class="nv">op</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">apply-generic</span> <span class="nv">op</span> <span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">arg</span> <span class="nv">op</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-from-mag-ang</span> <span class="nv">m</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">op</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'real-part</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">m</span> <span class="p">(</span><span class="nb">cos </span><span class="nv">a</span><span class="p">)))</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'imag-part</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">m</span> <span class="p">(</span><span class="nb">sin </span><span class="nv">a</span><span class="p">)))</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'magnitude</span><span class="p">)</span> <span class="nv">m</span><span class="p">)</span>
	  <span class="p">((</span><span class="nb">eq? </span><span class="nv">op</span> <span class="ss">'angle</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">else</span>
	   <span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown op -- MAKE-FROM-MAG-ANG"</span> <span class="nv">op</span><span class="p">))))</span>
  <span class="nv">dispatch</span><span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">real-part </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'real-part</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">imag-part </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'imag-part</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">magnitude </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'magnitude</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">angle </span><span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nf">apply-generic</span> <span class="ss">'angle</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nb">real-part </span><span class="p">(</span><span class="nf">make-from-real-imag</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>


<div id="outline-container-orga87bdec" class="outline-2">
<h2 id="orga87bdec">Упражнение 2.76</h2>
<div class="outline-text-2" id="text-orga87bdec">
<p>
При эволюционировании системы с общими процедурами, могут потребоваться новые типы данных или новые операции. Для каждой из трех стратегий
</p>

<p>
общие операции с явным выбором по типу
дата ориентированный подход (через хеш таблицы)
и подход получения сообщения (через dispatch в конструкторе)
</p>

<p>
опишите изменения которые должны быть внесены для нового типа или новой операции <code>[3/3]</code>
</p>

<ul class="org-ul">
<li class="on">
<code>[X]</code> при явном выборе метода по типу, нужно изменить <b>все общие методы</b> добавив туда дополнительные условия обработки нового типа. если добавляется метод, то нужно реализовать <b>общий метод</b> с выбором частного метода <b>для каждого типа</b>.</li>

<li class="on">
<code>[X]</code> при использовании дата ориентированного подхода если добавляется новый метод, реализовать интерфейс для этого метода для каждого типа, если добавляется новый тип, нужно реализовать интерфейсные методы для данного типа. <b>Важно что при этом не меняется старый код.</b>
</li>

<li class="on">
<code>[X]</code> при использовании message-passing при добавлении метода, нужно изменить конструкторы всех типов, добавив туда обработку нового метода, если добавляется новый тип, достаточно описать новый конструктор. То есть <b>при добавлении типа, старый код не меняется</b>, но <b>при добавлении метода, придется менять конструкторы в старом коде</b>.</li>
</ul>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-23-simvolicheskie-dannye/" class="u-url">SICP 2.3 Символические данные.</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-23-simvolicheskie-dannye/" rel="bookmark">
            <time class="published dt-published" datetime="2020-01-23T01:03:21+03:00" itemprop="datePublished" title="2020-01-23 01:03">2020-01-23 01:03</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-org3297eb5" class="outline-2">
<h2 id="org3297eb5">Упражнение 2.54</h2>
<div class="outline-text-2" id="text-org3297eb5">
<p>
Два списка называются равными если они содержат одинаковые элементы в одной последовательности. Определите equal? как рекурсивную функцию сравнения при помощи eq?.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">pair? </span><span class="nv">b</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">eq? </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">b</span><span class="p">))</span> <span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">b</span><span class="p">)))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org1901cd8" class="outline-2">
<h2 id="org1901cd8">Упражнение 2.55</h2>
<div class="outline-text-2" id="text-org1901cd8">
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">car </span><span class="o">'</span><span class="ss">'abracadabra</span><span class="p">)</span>
<span class="c1">;; '''asdfsfsf = (quote (quote asdfsfsf))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org51fd1bc" class="outline-2">
<h2 id="org51fd1bc">Упражнение 2.56</h2>
<div class="outline-text-2" id="text-org51fd1bc">
<p>
Покажите как расширить базовое дифференцирование чтобы оно могло обрабатывать больше видов выражений. Например реализовав правило  \(\frac{d(u^n)}{dx}=nu^{n-1}\frac{du}{dx}\) 
добавив условие на проверку экспоненты и реализовав определения exponentiation?, base, exponent и make-exponentiation.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exponentiation?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'**</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">base</span> <span class="nv">exponentiation</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">exponentiation</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exponent</span> <span class="nv">exponentiation</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">exponentiation</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-exponentiation</span> <span class="nv">b1</span> <span class="nv">e2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">=number?</span> <span class="nv">e2</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">=number?</span> <span class="nv">e2</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b1</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">=number?</span> <span class="nv">b1</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">b1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">e2</span><span class="p">))</span> <span class="p">(</span><span class="nb">expt </span><span class="nv">b1</span> <span class="nv">e2</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">list </span><span class="ss">'**</span> <span class="nv">b1</span> <span class="nv">e2</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
	<span class="p">((</span><span class="nf">sum?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">addend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">augend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
	<span class="p">((</span><span class="nf">product?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-sum</span>
	   <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
	   <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">))))</span>
	<span class="p">((</span><span class="nf">exponentiation?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span>
				     <span class="p">(</span><span class="nf">make-exponentiation</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span>
							  <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span>
								    <span class="mi">-1</span><span class="p">)))</span>
		       <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">else</span>
	 <span class="p">(</span><span class="nf">error</span> <span class="s">"unknown expression type -- DERIV"</span> <span class="nv">exp</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">**</span> <span class="nv">x</span> <span class="mi">4</span><span class="p">)</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgc07f50d" class="outline-2">
<h2 id="orgc07f50d">Упражнение 2.57</h2>
<div class="outline-text-2" id="text-orgc07f50d">
<p>
Расширьте программу для дифференцирования что бы сумма и умножение могло вычисляться двух или более под выражений. То есть что бы можно было писать так.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">*</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">))</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>

<p>
Попробуйте добиться этого изменяя только представление суммы и умножения, не изменяя саму функцию deriv.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span> <span class="o">.</span> <span class="nv">an</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">a2</span><span class="p">))</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span> <span class="nv">an</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="nv">an</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span> <span class="o">.</span> <span class="nv">mn</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nf">=number?</span> <span class="nv">m1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">=number?</span> <span class="nv">m2</span> <span class="mi">0</span><span class="p">))</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">;; ((=number? m1 1) m2)</span>
	<span class="c1">;; ((=number? m2 1) m1)</span>
	<span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">m1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">m2</span><span class="p">))</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="p">(</span><span class="nb">* </span><span class="nv">m1</span> <span class="nv">m2</span><span class="p">))</span> <span class="nv">mn</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'*</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span> <span class="nv">mn</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">s</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">caddr </span><span class="nv">s</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">s</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplier</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">p</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">caddr </span><span class="nv">p</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'*</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">p</span><span class="p">)))))</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgb1537f1" class="outline-2">
<h2 id="orgb1537f1">Упражнение 2.58</h2>
<div class="outline-text-2" id="text-orgb1537f1">
<p>
Предположим мы хотим записывать программу для дифференцирования в обычной математической нотации. <code>[2/2]</code>
</p>

<ul class="org-ul">
<li class="on">
<code>[X]</code> предложите решение когда сумма и умножение всегда принимают два аргумента и приоритет выражений полностью задан скобками (x + (3 * (x + (y + 2))))</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol? </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable?</span> <span class="nv">v2</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'+</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="nf">addend</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">augend</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="nv">m1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'*</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">m2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">product?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'*</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplier</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">product?</span> <span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">multiplier</span> <span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">multiplicand</span> <span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>

<ul class="org-ul">
<li class="on">
<code>[X]</code> проблема становится сложнее если опустить необязательные скобки и подразумевать что умножение имеет приоритет над суммой, предложите свое решение для этого случая (x + 3 * (x + y + 2)) когда аргументов может быть более 2.</li>
</ul>
<p>
еще может быть вот такой случай (x + 3 * (x + y + 2) + (x * x)) тут после второй итерации нужно делать не умножение а ещё одну сумму.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="nv">op</span> <span class="nv">exp</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">exp</span><span class="p">)</span> <span class="nv">op</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="nv">op</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum?</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fop</span> <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="ss">'+</span> <span class="nv">s</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">&gt; </span><span class="nv">fop</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rev</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fop</span> <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="ss">'+</span> <span class="nv">rev</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nf">addends</span> <span class="p">()))</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">ss</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="nv">ss</span>
	    <span class="p">(</span><span class="nf">iter-shift</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">ss</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">define </span><span class="nv">addends</span> <span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">rev</span> <span class="nv">fop</span><span class="p">))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">addends</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">car </span><span class="nv">addends</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">reverse </span><span class="nv">addends</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fop</span> <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="ss">'+</span> <span class="nv">s</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nf">aug</span> <span class="p">()))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">ss</span> <span class="nv">n</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	  <span class="nv">ss</span>
	  <span class="p">(</span><span class="nf">iter-shift</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">ss</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">aug</span> <span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">s</span> <span class="nv">fop</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">aug</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">car </span><span class="nv">aug</span><span class="p">)</span>
	<span class="nv">aug</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">x</span> <span class="nv">+</span> <span class="mi">3</span> <span class="nv">*</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">+</span> <span class="nv">y</span> <span class="nv">+</span> <span class="mi">2</span><span class="p">))</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org89b4f10" class="outline-2">
<h2 id="org89b4f10">Упражнение 2.59</h2>
<div class="outline-text-2" id="text-org89b4f10">
<p>
Определите процедуру union-set если set не отсортированный список.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">element-of-set?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))))</span>
</pre></div>

<p>
так как все процедуры используют element-of-set? эта функция сильно влияет на порядок роста. Порядок роста для element-of-set? и adjoin-set равен n. Для intersection-set и union-set n<sup>2</sup>.
</p>
</div>
</div>

<div id="outline-container-orgc43a71b" class="outline-2">
<h2 id="orgc43a71b">Упражнение 2.60</h2>
<div class="outline-text-2" id="text-orgc43a71b">
<p>
Предположим сеты могут иметь дубликаты. Реализуйте методы для сетов для такой структуры. Как от этого изменится порядок роста?
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">element-of-set?</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">equal? </span><span class="nv">x</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">))</span> <span class="nv">true</span><span class="p">)</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">element-of-set?</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">set</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">))</span> <span class="o">'</span><span class="p">())</span>
	<span class="p">((</span><span class="nf">element-of-set?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
	 <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">append </span><span class="nv">set1</span> <span class="nv">set2</span><span class="p">))</span>
</pre></div>

<p>
Для element-of-set порядок роста n, для adjoin-set 1, для intersection-set n<sup>2</sup>, для union-set n (так как append займет n).
</p>
</div>
</div>

<div id="outline-container-orga4b7165" class="outline-2">
<h2 id="orga4b7165">Упражнение 2.61</h2>
<div class="outline-text-2" id="text-orga4b7165">
<p>
Дайте определение adjoin-set для сортированных списков.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">))</span>
	<span class="p">((</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">))</span> <span class="nv">set</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">set</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set</span><span class="p">))))))</span>
</pre></div>
<p>
порядок роста по прежнему n, но иногда работает быстрее.
</p>
</div>
</div>

<div id="outline-container-org2d060af" class="outline-2">
<h2 id="org2d060af">Упражнение 2.62</h2>
<div class="outline-text-2" id="text-org2d060af">
<p>
Приведите определение union-set с порядком роста n.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)))</span>
		<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span>
			     <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span>
					<span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))</span>
		      <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span> <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
		      <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">cons </span><span class="nv">x2</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))))))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orged02fc2" class="outline-2">
<h2 id="orged02fc2">Упражнение 2.63</h2>
<div class="outline-text-2" id="text-orged02fc2">
<p>
Обе процедуры приведенные ниже трансформируют дерево в список.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span>
      <span class="o">'</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">))</span>
	      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">)</span>
		    <span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">copy-to-list</span> <span class="nv">tree</span> <span class="nv">result-list</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span>
	<span class="nv">result-list</span>
	<span class="p">(</span><span class="nf">copy-to-list</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">)</span>
		      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">)</span>
			    <span class="p">(</span><span class="nf">copy-to-list</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)</span>
					  <span class="nv">result-list</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">copy-to-list</span> <span class="nv">tree</span> <span class="o">'</span><span class="p">()))</span>
</pre></div>

<p>
a. Будут ли отличаться результаты двух процедур? Какие списки будут для дерева с рисунка 2.16
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">tree1</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">7</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">3</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">1</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">5</span> <span class="p">()</span> <span class="p">()))</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">9</span>
				    <span class="p">()</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">11</span> <span class="p">()</span> <span class="p">()))))</span>

<span class="nv">tree1</span>
<span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree1</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">tree2</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">3</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">7</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">5</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">9</span>
					       <span class="p">()</span>
					       <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">11</span> <span class="p">()</span> <span class="p">())))</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">1</span>
				    <span class="p">()</span>
				    <span class="p">())))</span>

<span class="nv">tree2</span>
<span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree2</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">tree3</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">5</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">3</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">1</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">())</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">9</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">7</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">11</span> <span class="p">()</span> <span class="p">()))))</span>
<span class="nv">tree3</span>
<span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree3</span><span class="p">)</span>
</pre></div>

<p>
списки одинаковые
</p>

<p>
b. как отличается порядок роста?
в первом случае за счет линейного времени append, порядок роста n*log(n)
во втором случае порядок роста будет n.
</p>
</div>
</div>

<div id="outline-container-org8be82d5" class="outline-2">
<h2 id="org8be82d5">Упражнение 2.64</h2>
<div class="outline-text-2" id="text-org8be82d5">
<p>
Следующая процедура list-&gt;tree преобразует отсортированный список в сбалансированное бинарное дерево. Вспомогательная процедура partial-tree принимает в качестве аргументов целое n и список и строит сбалансированное  бинарное дерево содержащее первые n элементов списка. Результат это функции - пара, первое значение это созданное дерево, а cdr элементы не вошедшие в дерево.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="nv">elements</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elements</span> <span class="p">(</span><span class="nb">length </span><span class="nv">elements</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elts</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="o">'</span><span class="p">()</span> <span class="nv">elts</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">left-size</span> <span class="p">(</span><span class="nb">quotient </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">left-result</span> <span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elts</span> <span class="nv">left-size</span><span class="p">)))</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">left-tree</span> <span class="p">(</span><span class="nb">car </span><span class="nv">left-result</span><span class="p">))</span>
		<span class="p">(</span><span class="nf">non-left-elts</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">left-result</span><span class="p">))</span>
		<span class="p">(</span><span class="nf">right-size</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">left-size</span> <span class="mi">1</span><span class="p">))))</span>
	    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">this-entry</span> <span class="p">(</span><span class="nb">car </span><span class="nv">non-left-elts</span><span class="p">))</span>
		  <span class="p">(</span><span class="nf">right-result</span> <span class="p">(</span><span class="nf">partial-tree</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">non-left-elts</span><span class="p">)</span>
					      <span class="nv">right-size</span><span class="p">)))</span>
	      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">right-tree</span> <span class="p">(</span><span class="nb">car </span><span class="nv">right-result</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">remaining-elts</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">right-result</span><span class="p">)))</span>
		<span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">make-tree</span> <span class="nv">this-entry</span> <span class="nv">left-tree</span> <span class="nv">right-tree</span><span class="p">)</span>
		      <span class="nv">remaining-elts</span><span class="p">))))))))</span>
</pre></div>

<p>
a. Кратко опишите как работает partial-tree. Нарисуйте дерево для списка (1 3 5 7 9 11).
</p>

<p>
Берем половину списка, строим от него дерево из первых int((n-1)/2 элементов. берем следующий элемент это будет вершина дерева, берем остальные элементы это будет правая часть дерева. для левой и правой стороны дерева процесс построения рекурсивно повторяется.
</p>

<div class="highlight"><pre><span></span><span class="c1">;Value: ((5 (1 () (3 () ())) (9 (7 () ()) (11 () ()))))</span>

	   <span class="mi">5</span>
	<span class="nv">/</span>      <span class="err">\</span>
       <span class="mi">1</span>         <span class="mi">9</span>
	<span class="err">\</span>       <span class="nv">/</span>  <span class="err">\</span>
     <span class="p">()</span>  <span class="mi">3</span>     <span class="mi">7</span>    <span class="mi">11</span>
	<span class="nv">/</span> <span class="err">\</span>   <span class="nv">/</span><span class="err">\</span>    <span class="nv">/</span> <span class="err">\</span>
       <span class="p">()</span> <span class="p">()</span> <span class="p">()()</span>  <span class="p">()</span>  <span class="p">()</span>
</pre></div>

<p>
b. Каков порядок роста list-&gt;tree?
</p>

<p>
Порядок роста n.
</p>
</div>
</div>

<div id="outline-container-org517d17c" class="outline-2">
<h2 id="org517d17c">Упражнение 2.65</h2>
<div class="outline-text-2" id="text-org517d17c">
<p>
Используя результаты упражнений 2.63 и 2.64 приведите определение union-set и intersection-set для множеств определенных как сбалансированные бинарные деревья.
</p>

<div class="highlight"><pre><span></span>	<span class="mi">4</span>                     <span class="mi">7</span>
      <span class="nv">/</span>  <span class="err">\</span>                <span class="nv">/</span>      <span class="err">\</span>
     <span class="mi">3</span>    <span class="mi">5</span>              <span class="mi">1</span>         <span class="mi">9</span>
    <span class="nv">/</span> <span class="err">\</span>   <span class="nv">/</span> <span class="err">\</span>              <span class="err">\</span>       <span class="nv">/</span>  <span class="err">\</span>
  <span class="p">()</span>   <span class="mi">1</span> <span class="mi">6</span>   <span class="mi">11</span>         <span class="p">()</span>  <span class="mi">3</span>     <span class="mi">8</span>    <span class="mi">11</span>
			   <span class="nv">/</span> <span class="err">\</span>   <span class="nv">/</span><span class="err">\</span>    <span class="nv">/</span> <span class="err">\</span>
			  <span class="p">()</span> <span class="p">()</span> <span class="p">()()</span>  <span class="p">()</span>  <span class="p">()</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-tree-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">orderedlist1</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">orderedlist2</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set2</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)))</span>
		    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
			   <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span>
				 <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span>
					    <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))</span>
			  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
			   <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span> <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
			  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
			   <span class="p">(</span><span class="nb">cons </span><span class="nv">x2</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))))))))</span>

    <span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">orderedlist1</span> <span class="nv">orderedlist2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intersection-tree-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">orderedlist1</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">orderedlist2</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set2</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">))</span>
	  <span class="o">'</span><span class="p">()</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)))</span>
	    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span>
			 <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span>
					   <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))</span>
		  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">))</span>
		  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))))))</span>
    <span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">orderedlist1</span> <span class="nv">orderedlist2</span><span class="p">))))</span>
</pre></div>

<p>
так как tree-&gt;list-2, list-&gt;tree и intersection-set, union-set (на сортированных списках) имеют порядок роста n, то и последовательное применение этих алгоритмов также имеет такой же порядок роста.
</p>
</div>
</div>

<div id="outline-container-org93769a0" class="outline-2">
<h2 id="org93769a0">Упражнение 2.66</h2>
<div class="outline-text-2" id="text-org93769a0">
<p>
Определите lookup для бинарного дерева.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lookup</span> <span class="nv">given-key</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">equal? </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span>
	<span class="p">((</span><span class="nb">&gt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)))</span>
	<span class="p">((</span><span class="nb">&lt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">)))))</span>
</pre></div>

<p>
log n
</p>
</div>
</div>

<div id="outline-container-orgb3dd010" class="outline-2">
<h2 id="orgb3dd010">Упражнение 2.67</h2>
<div class="outline-text-2" id="text-orgb3dd010">
<p>
Дано кодирующее дерево и сообщение, используя decode расшифруйте сообщение.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">sample-tree</span>
  <span class="p">(</span><span class="nf">make-code-tree</span> <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'A</span> <span class="mi">4</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">make-code-tree</span>
		   <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">make-code-tree</span> <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'D</span> <span class="mi">1</span><span class="p">)</span>
				   <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'C</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">sample-message</span> <span class="o">'</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">decode</span> <span class="nv">sample-message</span> <span class="nv">sample-tree</span><span class="p">)</span>
<span class="c1">;Value: (a d a b b c a)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org2ad5157" class="outline-2">
<h2 id="org2ad5157">Упражнение 2.68</h2>
<div class="outline-text-2" id="text-org2ad5157">
<p>
Процедура encode принимает на вход сообщение и дерево и генерирует последовательность бит.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="nv">symbols</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">symbols</span><span class="p">)</span>
      <span class="nv">false</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">symbol</span> <span class="p">(</span><span class="nb">car </span><span class="nv">symbols</span><span class="p">))</span>
	  <span class="nv">true</span>
	  <span class="p">(</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">symbols</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">in-list?</span> <span class="ss">'A</span> <span class="o">'</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">symbol</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">l-branch</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">r-branch</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="p">(</span><span class="nf">symbols</span> <span class="nv">l-branch</span><span class="p">))</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">l-branch</span><span class="p">)</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'0</span> <span class="p">())</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'0</span> <span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">symbol</span> <span class="nv">l-branch</span><span class="p">))))</span>
	  <span class="p">((</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="p">(</span><span class="nf">symbols</span> <span class="nv">r-branch</span><span class="p">))</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">r-branch</span><span class="p">)</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'1</span> <span class="p">())</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'1</span> <span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">symbol</span> <span class="nv">r-branch</span><span class="p">))))</span>
	  <span class="p">(</span><span class="nf">else</span>
	   <span class="p">(</span><span class="nf">error</span> <span class="s">"not exist symbol -- ENCODE-SYMBOL"</span> <span class="nv">symbol</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">a</span> <span class="nv">d</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">sample-tree</span><span class="p">)</span> <span class="c1">;Value: (0 1 1 0 0 1 0 1 0 1 1 1 0)</span>
</pre></div>

<p>
Encode-symbol - процедура кодирующая один символ. Дайте определение этой процедуры. Протестируйте на результате упражнения 2.67.
</p>
</div>
</div>

<div id="outline-container-org6da5208" class="outline-2">
<h2 id="org6da5208">Упражнение 2.69</h2>
<div class="outline-text-2" id="text-org6da5208">
<p>
Следующая процедура генерирует дерево по Хафману из пар символ-частота.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">successive-merge</span> <span class="p">(</span><span class="nf">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)))</span>
</pre></div>

<p>
Make-leaf-set, процедура приведенная выше, сортирует пары. Нужно дать определение процедуры successive-merge, которая делает слияние элементов с наименьшим весом, пока не останется один элемент.
</p>

<div class="highlight"><pre><span></span><span class="c1">;; вставка отсортированная по весу</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">))</span>
	<span class="p">((</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">weight</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">weight</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">)))</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">set</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">)</span>
		    <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set</span><span class="p">))))))</span>

<span class="c1">;; получаем сортированный список листов.</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">pairs</span><span class="p">)</span>
      <span class="o">'</span><span class="p">()</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pair</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pairs</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">adjoin-set</span> <span class="p">(</span><span class="nf">make-leaf</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span>    <span class="c1">; symbol</span>
			       <span class="p">(</span><span class="nb">cadr </span><span class="nv">pair</span><span class="p">))</span>  <span class="c1">; frequency</span>
		    <span class="p">(</span><span class="nf">make-leaf-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pairs</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">successive-merge</span> <span class="nv">opairs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">opairs</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">car </span><span class="nv">opairs</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">merged</span> <span class="p">(</span><span class="nf">make-code-tree</span> <span class="p">(</span><span class="nb">car </span><span class="nv">opairs</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">opairs</span><span class="p">))))</span>
	<span class="p">(</span><span class="nb">display </span><span class="nv">merged</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">successive-merge</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">merged</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">opairs</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">successive-merge</span> <span class="p">(</span><span class="nf">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">gentree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'D</span> <span class="mi">1</span><span class="p">))))</span>
<span class="nv">gentree</span>
<span class="p">(</span><span class="nf">symbols</span> <span class="nv">gentree</span><span class="p">)</span>

<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">a</span> <span class="nv">d</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">gentree</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-org1498b35" class="outline-2">
<h2 id="org1498b35">Упражнение 2.70</h2>
<div class="outline-text-2" id="text-org1498b35">
<p>
Следующий 8ми символьный алфавит с заданными частотами повторения был разработан чтобы эффективно кодировать рок лирику пятидесятых.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-left">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">2</td>
<td class="org-left">NA</td>
<td class="org-right">16</td>
</tr>
<tr>
<td class="org-left">BOOM</td>
<td class="org-right">1</td>
<td class="org-left">SHA</td>
<td class="org-right">3</td>
</tr>
<tr>
<td class="org-left">GET</td>
<td class="org-right">2</td>
<td class="org-left">YIP</td>
<td class="org-right">9</td>
</tr>
<tr>
<td class="org-left">JOB</td>
<td class="org-right">2</td>
<td class="org-left">WAH</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<p>
Get a job
</p>

<p>
Sha na na na na na na na na
</p>

<p>
Get a job
</p>

<p>
Sha na na na na na na na na
</p>

<p>
Wah yip yip yip yip yip yip yip yip yip
</p>

<p>
Sha boom
</p>

<p>
Сколько бит потребуется для кодирования?
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">pairs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'BOOM</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'GET</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'JOB</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'NA</span> <span class="mi">16</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'SHA</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'YIP</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'WAH</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">lyric-tree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">song</span> <span class="o">'</span><span class="p">(</span><span class="nv">Get</span> <span class="nv">a</span> <span class="nv">job</span> <span class="nv">Sha</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">Get</span> <span class="nv">a</span> <span class="nv">job</span> <span class="nv">Sha</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">Wah</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">Sha</span> <span class="nv">boom</span><span class="p">))</span>
<span class="nv">song</span>

<span class="p">(</span><span class="nb">length </span><span class="p">(</span><span class="nf">encode</span> <span class="nv">song</span> <span class="nv">lyric-tree</span><span class="p">))</span>
<span class="c1">;; 84</span>

<span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nb">length </span><span class="nv">song</span><span class="p">))</span>

<span class="c1">;; 108</span>
<span class="c1">;; 22.333%</span>
</pre></div>
</div>
</div>

<div id="outline-container-org587e382" class="outline-2">
<h2 id="org587e382">Упражнение 2.71</h2>
<div class="outline-text-2" id="text-org587e382">
<p>
Предположим у нас есть дерево по Хафману для алфавита из n символов, частота которых 1,2,4,..,2<sup>(n-1)</sup>. Сделайте набросок дерева для n=5 и n=10. Сколько бит требуется в таком дереве что бы закодировать наиболее часто встречающийся символ? Наименее часто встречающийся?
</p>

<div class="highlight"><pre><span></span><span class="c1">;; n = 5</span>
<span class="c1">;; 1,2,4,8,16</span>
<span class="c1">;; (1,2, 3)</span>
<span class="c1">;; (1,2,4 7)</span>
<span class="c1">;; (1,2,4,8 15)</span>
<span class="c1">;; (1,2,4,8,16 31)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pairs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'D</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'E</span> <span class="mi">16</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">bin-tree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">))</span>
<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="nv">bin-tree</span><span class="p">)</span>
<span class="c1">;; (0 0 0 0)</span>


<span class="c1">;; (1,2,4,8,16,32 63)</span>

<span class="c1">;; n = 10</span>
<span class="c1">;; 1,2,4,8,16</span>
<span class="c1">;; (1,2, 3)</span>
<span class="c1">;; (1,2,4 7)</span>
<span class="c1">;; (1,2,4,8 15)</span>
<span class="c1">;; (1,2,4,8,16 31)</span>
<span class="c1">;; (1,2,4,8,16,32 63)</span>
<span class="c1">;; (1,2,4,8,16,32,64 127)</span>
<span class="c1">;; (1,2,4,8,16,32,64,128 255)</span>
<span class="c1">;; (1,2,4,8,16,32,64,128,256 511)</span>
<span class="c1">;; (1,2,4,8,16,32,64,128,256,512 1023)</span>

<span class="c1">;; чтобы закодировать самый частый символ 1 бит</span>
<span class="c1">;; чтобы закодировать самый редкий символ для n=5, </span>

<span class="c1">;; 1,2,4,8,16,32,64,128,256,512</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pairs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'D</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'E</span> <span class="mi">16</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'F</span> <span class="mi">32</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'G</span> <span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'H</span> <span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'I</span> <span class="mi">256</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'J</span> <span class="mi">512</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">bin-tree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">))</span>
<span class="nv">bin-tree</span>
<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="nv">bin-tree</span><span class="p">)</span>
<span class="c1">;; (0 0 0 0 0 0 0 0 0)</span>


		     <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span> <span class="mi">31</span>
		     <span class="nv">/</span>           <span class="err">\</span>
		<span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">15</span>      <span class="nv">e</span> <span class="mi">16</span>
		 <span class="nv">/</span>     <span class="err">\</span>
	   <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">7</span>    <span class="nv">d</span> <span class="mi">8</span>
	     <span class="nv">/</span>    <span class="err">\</span>
	<span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">3</span>    <span class="nv">c</span> <span class="mi">4</span>
	 <span class="nv">/</span>   <span class="err">\</span>
      <span class="nv">a</span> <span class="mi">1</span>    <span class="nv">b</span> <span class="mi">2</span>
<span class="c1">;; получается n-1 бит</span>
</pre></div>
</div>
</div>


<div id="outline-container-org364e2d4" class="outline-2">
<h2 id="org364e2d4">Упражнение 2.72</h2>
<div class="outline-text-2" id="text-org364e2d4">
<p>
Каков порядок роста для процедуры кодирования символа? Убедитесь что учли поиск вхождения символа. Ответить на этот вопрос в общем сложно. Поэтому рассмотрите частный случай когда частота символов при кодировании будет как в упражнении 2.71. И приведите порядок роста для кодирования наиболее часто встречающегося символа и наименее часто встречающегося символа.
</p>

<p>
для самого частого символа, нам нужно всего один раз проверить что символ встретился в алфавите, то есть порядок роста будет равен порядку роста поиска элемента в отсортированном списке, у нас это n (так как бинарное дерево не используется).
</p>

<p>
для самого редко встречающегося символа нам потребуется n -1 раз делать поиск по (n-1)/2 элементам то есть итоговый порядок роста будет n<sup>2</sup></p>

<p>
То есть общий ответ будет между n и n<sup>2</sup>.
</p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/sicp-224-primer-iazyk-izobrazhenii/" class="u-url">SICP 2.2.4 Пример: Язык изображений.</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="posts/sicp-224-primer-iazyk-izobrazhenii/" rel="bookmark">
            <time class="published dt-published" datetime="2020-01-21T21:12:26+03:00" itemprop="datePublished" title="2020-01-21 21:12">2020-01-21 21:12</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div id="outline-container-org7c6fd9b" class="outline-2">
<h2 id="org7c6fd9b">Упражнение 2.44.</h2>
<div class="outline-text-2" id="text-org7c6fd9b">
<p>
Определите процедуру up-split используемую в corner-split.
</p>

<p>
<img src="images/up-split-einstein.png" alt="nil"></p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">up-split</span> <span class="nv">painter</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">painter</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">smaller</span> <span class="p">(</span><span class="nf">up-split</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
	<span class="p">(</span><span class="nf">below</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">beside</span> <span class="nv">smaller</span> <span class="nv">smaller</span><span class="p">)))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgc1f752f" class="outline-2">
<h2 id="orgc1f752f">Упражнение 2.45.</h2>
<div class="outline-text-2" id="text-orgc1f752f">
<p>
Определите процедуру обобщение up-split right-split.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">split</span> <span class="nv">fs</span> <span class="nv">ss</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">painter,</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nv">painter</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">smaller</span> <span class="p">((</span><span class="nf">split</span> <span class="nv">fs</span> <span class="nv">ss</span><span class="p">)</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
	  <span class="p">(</span><span class="nf">fs</span> <span class="nv">painter</span> <span class="p">(</span><span class="nf">ss</span> <span class="nv">smaller</span> <span class="nv">smaller</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">right-split</span> <span class="p">(</span><span class="nf">split</span> <span class="nv">beside</span> <span class="nv">below</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">up-split</span> <span class="p">(</span><span class="nf">split</span> <span class="nv">below</span> <span class="nv">beside</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7d94fea" class="outline-2">
<h2 id="org7d94fea">Упражнение 2.46</h2>
<div class="outline-text-2" id="text-org7d94fea">
<p>
Двумерный вектор v проведенный из точки отсчета в некоторую точку может быть представлен как пара координат x и y. Реализуйте абстракцию для векторов задав конструктор make-vect и соответствующие селекторы xcor-vect, ycor-vect. Реализуйте процедуры add-vect, sub-vect и scale-vect, которые выполняют операции над вектором.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-vect</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">v</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="nv">v</span><span class="p">))</span>
<span class="p">(</span><span class="nf">ycor-vect</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-vect</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v2</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-vect</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v2</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v2</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scale-vect</span> <span class="nv">v</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org91bb85a" class="outline-2">
<h2 id="org91bb85a">Упражнение 2.47</h2>
<div class="outline-text-2" id="text-org91bb85a">
<p>
Здесь две возможных конструктора для фреймов:
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-frame</span> <span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-frame</span> <span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">origin</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">)))</span>
</pre></div>

<p>
Для каждого конструктора укажите соответствующие селекторы что бы реализовать процедуры для фреймов.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">origin-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">frame</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">edge1-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cadr </span><span class="nv">frame</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">edge1-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cadr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">frame</span><span class="p">)))</span>

<span class="c1">;; 2</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">origin-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">frame</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">edge1-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">frame</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">edge1-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">frame</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6773718" class="outline-2">
<h2 id="org6773718">Упражнение 2.48</h2>
<div class="outline-text-2" id="text-org6773718">
<p>
Сегмент направленной линии на плоскости может быть представлен в виде пары векторов: вектор идущий от начала координат до начальной точки сегмента и вектор идущий от начала координат до конечной точки сегмента. Используя векторное представление из 2.46 что бы определить представление для сегментов с конструктором make-segment и селекторами start-segment, end-segment.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-segment</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">start-segment</span> <span class="nv">seg</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">seg</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">end-segment</span> <span class="nv">seg</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="nv">seg</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgd1f80c5" class="outline-2">
<h2 id="orgd1f80c5">Упражнение 2.49</h2>
<div class="outline-text-2" id="text-orgd1f80c5">
<p>
Используя segments-&gt;painter определите следующие процедуры
a. Нарисовать контур обозначенной рамки.
b. Нарисовать Х соединяющий противоположные углы рамки.
c. Нарисовать ромбовидную форму соединяющую центры рамки.
d. Нарисовать волну.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">for-each </span><span class="nv">proc</span> <span class="nv">items</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">items</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">proc</span> <span class="p">(</span><span class="nb">car </span><span class="nv">items</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">null? </span><span class="nv">items</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">for-each </span><span class="nv">proc</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">items</span><span class="p">)))</span>
  <span class="nv">true</span><span class="p">)</span>
<span class="c1">;; frame</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-frame</span> <span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">list </span><span class="nv">origin</span> <span class="nv">edge1</span> <span class="nv">edge2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">origin-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">frame</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">edge1-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">card</span> <span class="nv">frame</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">edge2-frame</span> <span class="nv">frame</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">card</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">frame</span><span class="p">)))</span>

<span class="c1">;; segment</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-segment</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">start-segment</span> <span class="nv">seg</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">seg</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">end-segment</span> <span class="nv">seg</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="nv">seg</span><span class="p">))</span>

<span class="c1">;; vector</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-vect</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="nv">v</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cdr </span><span class="nv">v</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-vect</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v2</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sub-vect</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v2</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v2</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scale-vect</span> <span class="nv">v</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-vect</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">xcor-vect</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">ycor-vect</span> <span class="nv">v</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>

<span class="c1">;; a</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">segments-&gt;painter</span> <span class="nv">segment-list</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">frame</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">for-each</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">segment</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">draw-line</span>
	<span class="p">((</span><span class="nf">frame-coord-map</span> <span class="nv">frame</span><span class="p">)</span> <span class="p">(</span><span class="nf">start-segment</span> <span class="nv">segment</span><span class="p">))</span>
	<span class="p">((</span><span class="nf">frame-coord-map</span> <span class="nv">frame</span><span class="p">)</span> <span class="p">(</span><span class="nf">end-segment</span> <span class="nv">segment</span><span class="p">))))</span>
     <span class="nv">segment-list</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">frame1</span> <span class="p">(</span><span class="nf">make-frame</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">segment-list-a</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">))</span>
			    <span class="p">))</span>

<span class="p">((</span><span class="nf">segments-&gt;painter</span> <span class="nv">segment-list-a</span><span class="p">)</span> <span class="nv">frame1</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">segment-list-b</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
			    <span class="p">))</span>

<span class="p">((</span><span class="nf">segments-&gt;painter</span> <span class="nv">segment-list-b</span><span class="p">)</span> <span class="nv">frame1</span><span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="nv">segment-list-c</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.5</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mf">0.5</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.5</span> <span class="mi">1</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.5</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mf">0.5</span><span class="p">))</span>
			    <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.5</span> <span class="mi">0</span><span class="p">))</span>
			    <span class="p">))</span>

<span class="p">((</span><span class="nf">segments-&gt;painter</span> <span class="nv">segment-list-c</span><span class="p">)</span> <span class="nv">frame1</span><span class="p">)</span>


<span class="p">(</span><span class="k">define </span><span class="nv">segment-list-d</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">25</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">35</span> <span class="o">.</span><span class="mi">5</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">35</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">3</span> <span class="o">.</span><span class="mi">6</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">3</span> <span class="o">.</span><span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">15</span> <span class="o">.</span><span class="mi">4</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">15</span> <span class="o">.</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="o">.</span><span class="mi">65</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="o">.</span><span class="mi">65</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="o">.</span><span class="mi">85</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">0</span> <span class="o">.</span><span class="mi">85</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">15</span> <span class="o">.</span><span class="mi">6</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">15</span> <span class="o">.</span><span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">3</span> <span class="o">.</span><span class="mi">65</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">3</span> <span class="o">.</span><span class="mi">65</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">4</span> <span class="o">.</span><span class="mi">65</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">4</span> <span class="o">.</span><span class="mi">65</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">35</span> <span class="o">.</span><span class="mi">85</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">35</span> <span class="o">.</span><span class="mi">85</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">4</span> <span class="mi">1</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">4</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="mi">1</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">65</span> <span class="o">.</span><span class="mi">85</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">65</span> <span class="o">.</span><span class="mi">85</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="o">.</span><span class="mi">65</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="o">.</span><span class="mi">65</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">75</span> <span class="o">.</span><span class="mi">65</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">75</span> <span class="o">.</span><span class="mi">65</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="o">.</span><span class="mi">35</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="o">.</span><span class="mi">35</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="o">.</span><span class="mi">15</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mi">1</span> <span class="o">.</span><span class="mi">15</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="o">.</span><span class="mi">45</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="o">.</span><span class="mi">45</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">75</span> <span class="mi">0</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">75</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="mi">0</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">6</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">5</span> <span class="o">.</span><span class="mi">3</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">5</span> <span class="o">.</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">4</span> <span class="mi">0</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">4</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">25</span> <span class="mi">0</span><span class="p">))</span>
			     <span class="p">))</span>

<span class="p">((</span><span class="nf">segments-&gt;painter</span> <span class="nv">segment-list-d</span><span class="p">)</span> <span class="nv">frame1</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orge422d16" class="outline-2">
<h2 id="orge422d16">Упражнение 2.50</h2>
<div class="outline-text-2" id="text-orge422d16">
<p>
Определите процедуру flip-horiz и трансформации которые вращают изображения против часовой стрелки на 180 и 270 градусов.
</p>


<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">flip-horiz</span> <span class="nv">painter</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter</span>
		     <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">1.0</span> <span class="o">.</span><span class="mi">0</span><span class="p">)</span>
		     <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">0</span> <span class="o">.</span><span class="mi">0</span><span class="p">)</span>
		     <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">1.0</span> <span class="mf">1.0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">repeated</span> <span class="nv">f</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rotate90</span> <span class="nv">painter</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter</span>
		     <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">1.0</span> <span class="mf">0.0</span><span class="p">)</span>
		     <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">1.0</span> <span class="mf">1.0</span><span class="p">)</span>
		     <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rotate270</span> <span class="nv">painter</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">repeated</span> <span class="nv">rotate90</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">painter</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">rotate180</span> <span class="nv">painter</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">repeated</span> <span class="nv">rotate90</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">painter</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6a92d68" class="outline-2">
<h2 id="org6a92d68">Упражнение 2.51</h2>
<div class="outline-text-2" id="text-org6a92d68">
<p>
Определите процедуру below. Как аналог beside и второй раз через beside и подходящие трасформации.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">below</span> <span class="nv">painter1</span> <span class="nv">painter2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">split-point</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.0</span> <span class="mf">0.5</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">paint-bottom</span>
	   <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter1</span>
			      <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">)</span>
			      <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">1.0</span> <span class="mf">0.0</span><span class="p">)</span>
			      <span class="nv">split-point</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">paint-top</span>
	   <span class="p">(</span><span class="nf">transform-painter</span> <span class="nv">painter2</span>
			      <span class="nv">split-point</span>
			      <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">1.0</span> <span class="mf">0.5</span><span class="p">)</span>
			      <span class="p">(</span><span class="nf">make-vect</span> <span class="mf">0.0</span> <span class="mf">1.0</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">frame</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">paint-bottom</span> <span class="nv">frame</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">paint-top</span> <span class="nv">frame</span><span class="p">)))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">below-2</span> <span class="nv">painter1</span> <span class="nv">painter2</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">rotate270</span> <span class="p">(</span><span class="nf">beside</span> <span class="nv">painter1</span> <span class="nv">painter2</span><span class="p">)))</span>
</pre></div>
</div>
</div>


<div id="outline-container-org67a1205" class="outline-2">
<h2 id="org67a1205">Упражнение 2.52</h2>
<div class="outline-text-2" id="text-org67a1205">
<p>
Внесите изменение в square-limit на разных уровнях абстракции
а. Добавьте какие-нибудь сегменты к примитиву wave.
</p>

<div class="highlight"><pre><span></span><span class="c1">;; тут просто добавляем в список элементов пару сегментов</span>
<span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">5</span> <span class="o">.</span><span class="mi">75</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">5</span> <span class="o">.</span><span class="mi">77</span><span class="p">))</span>
<span class="p">(</span><span class="nf">make-segment</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">45</span> <span class="o">.</span><span class="mi">75</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-vect</span> <span class="o">.</span><span class="mi">55</span> <span class="o">.</span><span class="mi">75</span><span class="p">))</span>
</pre></div>

<p>
б. измените corner-split (к примеру используя только одну копию up-split и right-split вместо двух).
</p>

<div class="highlight"><pre><span></span><span class="c1">;; тут просто редактируем функцию corner-split</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">corner-split</span> <span class="nv">painter</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">painter</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">up</span> <span class="p">(</span><span class="nf">up-split</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>
	    <span class="p">(</span><span class="nf">right</span> <span class="p">(</span><span class="nf">right-split</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">top-left</span> <span class="p">(</span><span class="nf">beside</span> <span class="nv">up</span> <span class="nv">up</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">bottom-right</span> <span class="p">(</span><span class="nf">below</span> <span class="nv">right</span> <span class="nv">right</span><span class="p">))</span>
	      <span class="p">(</span><span class="nf">corner</span> <span class="p">(</span><span class="nf">corner-split</span> <span class="nv">painter</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
	  <span class="p">(</span><span class="nf">beside</span> <span class="p">(</span><span class="nf">below</span> <span class="nv">painter</span> <span class="nv">top-left</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">below</span> <span class="nv">painter</span> <span class="nv">corner</span><span class="p">))))))</span>
</pre></div>
<p>
в. измените square-limit, что бы собрать углы по другому шаблону
</p>

<div class="highlight"><pre><span></span><span class="c1">;; тут просто редактируем функцию square-limit</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square-limit</span> <span class="nv">painter</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">combine4</span> <span class="p">(</span><span class="nf">square-of-four</span> <span class="nv">flip-vert</span> <span class="nv">rotate180</span>
				   <span class="nv">identity</span> <span class="nv">flip-horiz</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">combine4</span> <span class="p">(</span><span class="nf">corner-split</span> <span class="nv">painter</span> <span class="nv">n</span><span class="p">))))</span>
</pre></div>

<p>
пример программы показывает что мы делаем редактирование только на одном из уровней абстракций.
</p>
</div>
</div>
    </div>
    </article>
</div>
        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-2.html" rel="next">Старые записи</a>
            </li>
        </ul></nav></main><footer id="footer"><p>Contents © 2020         <a href="mailto:anton.s.pilipenko@gmail.com">Velikii Nehochuha</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
                <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
