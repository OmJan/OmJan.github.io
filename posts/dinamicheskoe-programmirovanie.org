#+BEGIN_COMMENT
.. title: Лекция 10-11, Динамическое программирование
.. slug: dinamicheskoe-programmirovanie
.. date: 2020-06-20 17:29:57 UTC+03:00
.. tags: python, algorithms
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT


#+BEGIN_SRC python
def fib_recusrion(n):
    if n < 2:
        return n
    return fib_recusrion(n-1) + fib_recusrion(n-2)


for i in range(10):
    print(fib_recusrion(i))
#+END_SRC

Очевидно что количество повторных вычислений неприемлимо велико
Экспотенциальный рост количества вычислений

#+BEGIN_SRC python
def fib_linier(n):
    if n in [0, 1]:
        return n
    assert n >= 2
    fib_list = [0, 1] + [0]*(n-1)
    for i in range(2, n+1):
        fib_list[i] = fib_list[i-2] + fib_list[i-1]
    return fib_list[-1]


for i in range(10):
    print(fib_linier(i))
#+END_SRC

Так все линейно

Сколько различных траекторий допрыгать из 1 в N? Если можно прыгнуть на 1 и на 2 клетки.

Кn = Kn-1 + Kn-2

Количество уникальных перестановок траекторий в точке N равно количеству уникальных траекторий в N-1 + количество уникальных траекторий в N-2 (перестановок - траекторий)

#+BEGIN_SRC python
def trajectory_num(n):
    if n in [0, 1]:
        return n
    assert n >= 2
    trajectory_num_list = [0, 1] + [0]*(n-1)
    for i in range(2, n+1):
        trajectory_num_list[i] = fib_list[i-2] + fib_list[i-1]
    return trajectory_num_list[-1]


for i in range(10):
    print(trajectory_num(i))
#+END_SRC

Запретим некоторые клетки для посещения и добавим еще один вариант переджвижения 3.

#+BEGIN_SRC python
def trajectory_num(n, allowed):
    if n in [0, 1, int(allowed[2])]:
        return n
    assert n >= 3
    trajectory_num_list = [0, 1, int(allowed[2])] + [0]*(n-1)
    for i in range(3, n):
        if allowed[i]:
            trajectory_num_list[i] = fib_list[i-3] + fib_list[i-2] + fib_list[i-1]
        else:
            trajectory_num_list[i] = 0
    return trajectory_num_list[-1]
#+END_SRC

*Минимальная стоимость посещение клетки N*

price[i] - за посещение клетки i
C[i] - минимально возможная стоимость достижения клетки i
пусть доступны шаги +1 и +2
Ci = price[i] + min(Ci-1, Ci-2)


#+BEGIN_SRC python
def count_min_cost(N, price: list):
    C = [float('-inf'), price[1], (price[1] + price[2]) + [0]*(N-2)]
    for i in range(3, N-1):
        C[i] = price[i] + min(price[i-1], price[i-2])
    return C[-1]
#+END_SRC

*Двумерное динамическое программирование.*

Шахматный король на доске MxN. Сколькими способами шахматный король может добраться до заданной клетки, если он может шагать только вправо и вниз.

Knm - количество способов достичь клетки (N,M)

Kij = K(i-1)j + Ki(j-1)

C из n по k - треугольник паскаля.


*Наибольшая общая последовательность*


A,B - массивы чисел len(A) == N, len(B) == M
Последовательность - С, содержит элементы А в исходном порядке, но возможно не все. При поиске важен порядок элементов! Если порядок не важен, нужно использовать другой алгоритм.

[] - последовательность - подпоследовательность любой последовательности А

Какая максимльная подпоследовательность у них общая.
Пусть Fij - длина наибольшей возможной подпоследовательности частей А и B.
Ai = A[0:i] - часть А содержащая первые i элементов
Bj = B[0:j] - часть B содержит первые j элементов

Fij


a1, a2, a3, a4, a5, .., ai
b1, b2,             .., bj

если ai = bj, то 1 + F(i-1)(j-1)

если ai != bj, то max(Fi(j-1), F(i-1)j)

F0j = 0
Fi0 = 0


| 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 |
| 0 | 1 | 1 | 1 | 1 |
| 0 | 1 | 2 | 2 | 2 |
| 0 | 1 | 2 | 2 | 3 |

#+BEGIN_SRC python
def _common_sequence(A, B):
    F = [[0]*(len(B)+1) for i in range(len(A)+1)]

    for i in range(1, len(A)+1):
        for j in range(1, len(B)+1):
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j] = max(F[i][j-1], F[i-1][j])
    return F


def l_common_sequence(A, B):
    F = _common_sequence(A, B)
    return F[-1][-1]


def find_common_sequence(A, B):
    F = _common_sequence(A, B)
    res = []
    for i in (range(1, len(A)+1)):
        for j in range(1, len(B) + 1):
            i_index = len(A) - i + 1
            j_index = len(B) - j + 1
            if F[i_index][j_index] != F[i_index-1][j_index] and F[i_index][j_index] != F[i_index][j_index-1]:
                res.append(A[i_index-1])
    return res[::-1]

print(find_common_sequence([8, 3, 7, 5], [8, 7, 6, 5]))

#+END_SRC


*Наибольшая возрастающая под последовательность*

#+BEGIN_SRC python
def gis(A):
    F = [1]*(len(A))
    for i in range(1, len(A)):
        m = 0
        for j in range(0, i):
            if A[i] > A[j] and F[j] > m:
                m = F[j]
        F[i] = m + 1
    return F[-1]


print(gis([8, 3, 7, 5, 9]))
#+END_SRC

*Алгоритм укладки рюкзака*

Есть мешок и некоторый набор предметов. M - максимальный вес который можно унести. У каждого предмета есть цена и масса. Какую максимальную стоимость предметов вы можете унести. Полностью задача решается только полным перебором.
Но дискретный алгоритм укладки рюкзака решается методом динамического программирования.

|            | цена | масса |
| гитара     | 1500 |     1 |
| магнитовон | 3000 |     4 |
| ноутбук    | 2000 |     3 |
| телефон    | 2000 |     1 |
| телефон    | 1000 |     1 |

| предмет/емкость рюкзака |    1 |    2 |    3 |    4 |
| гитара                  | 1500 | 1500 | 1500 | 1500 |
| магнитовон              | 1500 | 1500 | 1500 | 3000 |
| ноутбук                 | 1500 | 1500 | 2000 | 3500 |


Стоимость ячейки можно вычислить таким образом

CELL[i][j] = выбираем максимум из
1. Предведущий максимум (значение в CELL[i-1][j])
2. Стоимость текущего элемента + CELL[i-1][j-вес текущего]

можно добавлять элементы динамически к уже существующим элементам, например добавив телефон стоимостью 2000

| предмет/емкость рюкзака |    1 |    2 |    3 |    4 |
| гитара                  | 1500 | 1500 | 1500 | 1500 |
| магнитовон              | 1500 | 1500 | 1500 | 3000 |
| ноутбук                 | 1500 | 1500 | 2000 | 3500 |
| телефон                 | 2000 | 3500 | 3500 | 4000 |

Упражнение предположим добавили еще mp3 плеер, стоимостью 1000 и весом 1. Стоит ли брать его?

| предмет/емкость рюкзака |    1 |    2 |    3 |    4 |
| гитара                  | 1500 | 1500 | 1500 | 1500 |
| магнитовон              | 1500 | 1500 | 1500 | 3000 |
| ноутбук                 | 1500 | 1500 | 2000 | 3500 |
| телефон                 | 2000 | 3500 | 3500 | 4000 |
| плеер                   | 2000 | 3500 | 4500 | 4500 |

Ответ: да. стоит сумма будет 4500.

Что произойдет при изменении порядка строк?

| предмет/емкость рюкзака |    1 |    2 |    3 |    4 |
| магнитовон              |    0 |    0 |    0 | 3000 |
| ноутбук                 |    0 |    0 | 2000 | 3000 |
| гитара                  | 1500 | 1500 | 2000 | 3500 |

Видим что итоговый результат не изменился, хотя таблица заполнена иным образом.


Можно ли заполнять таблицу по столбцам а не по строкам?

Ответ: а данном случае вполне возможно.


*Оптимизация туристического маршрута*

| Достопримечательность     | Время   | Оценка |
| Вестминстерское аббатство | 0.5 дня |      7 |
| Театр «Глобус»            | 0.5 дня |      6 |
| Национальная галерея      | 1 день  |      9 |
| Британский музей          | 2 дня   |      9 |
| Собор св. Павла           | 0.5 дня |      8 |


| предмет/емкость рюкзака   | 0.5 |  1 | 1.5 |  2 |
| Вестминстерское аббатство |   7 |  7 |   7 |  7 |
| Театр «Глобус»            |   7 | 13 |  13 | 13 |
| Национальная галерея      |   7 | 13 |  16 | 22 |
| Британский музей          |   7 | 13 |  16 | 22 |
| Собор св. Павла           |   8 | 15 |  21 | 24 |


*Наибольшая общая последовательность*

если ai = bj, то 1 + F(i-1)(j-1)

если ai != bj, то max(Fi(j-1), F(i-1)j)


|   | f | o | s | h |
| f | 1 | 1 | 1 | 1 |
| i | 1 | 1 | 1 | 1 |
| s | 1 | 1 | 2 | 2 |
| h | 1 | 1 | 2 | 3 |
