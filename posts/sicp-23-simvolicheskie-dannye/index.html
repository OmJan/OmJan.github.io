<!DOCTYPE html>
<html prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>SICP 2.3 Символические данные. | VelikiiNehochuha Blog</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="../../rss.xml">
<link rel="canonical" href="http://velikiinehochuha.github.io/posts/sicp-23-simvolicheskie-dannye/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Velikii Nehochuha">
<link rel="prev" href="../sicp-224-primer-iazyk-izobrazhenii/" title="SICP 2.2.4 Пример: Язык изображений." type="text/html">
<link rel="next" href="../sicp-24-mnozhestvennye-predstavleniia-dlia-abstraktnykh-dannykh/" title="SICP 2.4 Множественные представления для абстрактных данных." type="text/html">
<meta property="og:site_name" content="VelikiiNehochuha Blog">
<meta property="og:title" content="SICP 2.3 Символические данные.">
<meta property="og:url" content="http://velikiinehochuha.github.io/posts/sicp-23-simvolicheskie-dannye/">
<meta property="og:description" content="Упражнение 2.54


Два списка называются равными если они содержат одинаковые элементы в одной последовательности. Определите equal? как рекурсивную функцию сравнения при помощи eq?.

(define (equal? a">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-01-23T01:03:21+03:00">
<meta property="article:tag" content="scheme">
<meta property="article:tag" content="sicp">
<meta property="article:tag" content="symbolic_data">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="../../" title="VelikiiNehochuha Blog" rel="home">

        <span id="blog-title">VelikiiNehochuha Blog</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="../../archive.html">Архив</a></li>
                <li><a href="../../categories/">Тэги</a></li>
                <li><a href="../../rss.xml">RSS лента</a></li>

    
    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">SICP 2.3 Символические данные.</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2020-01-23T01:03:21+03:00" itemprop="datePublished" title="2020-01-23 01:03">2020-01-23 01:03</time></a>
            </p>
                    <p class="sourceline"><a href="index.org" class="sourcelink">Источник</a></p>

        </div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div id="outline-container-org3a0bd10" class="outline-2">
<h2 id="org3a0bd10">Упражнение 2.54</h2>
<div class="outline-text-2" id="text-org3a0bd10">
<p>
Два списка называются равными если они содержат одинаковые элементы в одной последовательности. Определите equal? как рекурсивную функцию сравнения при помощи eq?.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">pair? </span><span class="nv">b</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">eq? </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">b</span><span class="p">))</span> <span class="p">(</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">b</span><span class="p">)))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org493dfe2" class="outline-2">
<h2 id="org493dfe2">Упражнение 2.55</h2>
<div class="outline-text-2" id="text-org493dfe2">
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">car </span><span class="o">'</span><span class="ss">'abracadabra</span><span class="p">)</span>
<span class="c1">;; '''asdfsfsf = (quote (quote asdfsfsf))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgf3c32ed" class="outline-2">
<h2 id="orgf3c32ed">Упражнение 2.56</h2>
<div class="outline-text-2" id="text-orgf3c32ed">
<p>
Покажите как расширить базовое дифференцирование чтобы оно могло обрабатывать больше видов выражений. Например реализовав правило  \(\frac{d(u^n)}{dx}=nu^{n-1}\frac{du}{dx}\) 
добавив условие на проверку экспоненты и реализовав определения exponentiation?, base, exponent и make-exponentiation.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exponentiation?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">car </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'**</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">base</span> <span class="nv">exponentiation</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">exponentiation</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">exponent</span> <span class="nv">exponentiation</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">exponentiation</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-exponentiation</span> <span class="nv">b1</span> <span class="nv">e2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">=number?</span> <span class="nv">e2</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">=number?</span> <span class="nv">e2</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b1</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">=number?</span> <span class="nv">b1</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">b1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">e2</span><span class="p">))</span> <span class="p">(</span><span class="nb">expt </span><span class="nv">b1</span> <span class="nv">e2</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">list </span><span class="ss">'**</span> <span class="nv">b1</span> <span class="nv">e2</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deriv</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">number? </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">variable?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">exp</span> <span class="nv">var</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
	<span class="p">((</span><span class="nf">sum?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">addend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">augend</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
	<span class="p">((</span><span class="nf">product?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-sum</span>
	   <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">))</span>
	   <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">multiplier</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">exp</span><span class="p">))))</span>
	<span class="p">((</span><span class="nf">exponentiation?</span> <span class="nv">exp</span><span class="p">)</span>
	 <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">make-product</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span>
				     <span class="p">(</span><span class="nf">make-exponentiation</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span>
							  <span class="p">(</span><span class="nf">make-sum</span> <span class="p">(</span><span class="nf">exponent</span> <span class="nv">exp</span><span class="p">)</span>
								    <span class="mi">-1</span><span class="p">)))</span>
		       <span class="p">(</span><span class="nf">deriv</span> <span class="p">(</span><span class="nf">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">var</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">else</span>
	 <span class="p">(</span><span class="nf">error</span> <span class="s">"unknown expression type -- DERIV"</span> <span class="nv">exp</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">**</span> <span class="nv">x</span> <span class="mi">4</span><span class="p">)</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgbb18f56" class="outline-2">
<h2 id="orgbb18f56">Упражнение 2.57</h2>
<div class="outline-text-2" id="text-orgbb18f56">
<p>
Расширьте программу для дифференцирования что бы сумма и умножение могло вычисляться двух или более под выражений. То есть что бы можно было писать так.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">*</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">3</span><span class="p">))</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>

<p>
Попробуйте добиться этого изменяя только представление суммы и умножения, не изменяя саму функцию deriv.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span> <span class="o">.</span> <span class="nv">an</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">a2</span><span class="p">))</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a1</span> <span class="nv">a2</span><span class="p">))</span> <span class="nv">an</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="nv">an</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span> <span class="o">.</span> <span class="nv">mn</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nf">=number?</span> <span class="nv">m1</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">=number?</span> <span class="nv">m2</span> <span class="mi">0</span><span class="p">))</span> <span class="mi">0</span><span class="p">)</span>
	<span class="c1">;; ((=number? m1 1) m2)</span>
	<span class="c1">;; ((=number? m2 1) m1)</span>
	<span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">m1</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">m2</span><span class="p">))</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span> <span class="p">(</span><span class="nb">* </span><span class="nv">m1</span> <span class="nv">m2</span><span class="p">))</span> <span class="nv">mn</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'*</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span> <span class="nv">mn</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">s</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">caddr </span><span class="nv">s</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'+</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">s</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplier</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">p</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">caddr </span><span class="nv">p</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="ss">'*</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">p</span><span class="p">)))))</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgdda4d12" class="outline-2">
<h2 id="orgdda4d12">Упражнение 2.58</h2>
<div class="outline-text-2" id="text-orgdda4d12">
<p>
Предположим мы хотим записывать программу для дифференцирования в обычной математической нотации. <code>[2/2]</code>
</p>

<ul class="org-ul">
<li class="on">
<code>[X]</code> предложите решение когда сумма и умножение всегда принимают два аргумента и приоритет выражений полностью задан скобками (x + (3 * (x + (y + 2))))</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">symbol? </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">same-variable?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nf">variable?</span> <span class="nv">v1</span><span class="p">)</span> <span class="p">(</span><span class="nf">variable?</span> <span class="nv">v2</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="nv">v1</span> <span class="nv">v2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'+</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="nf">addend</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">augend</span> <span class="p">(</span><span class="nf">make-sum</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-product</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="nv">m1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'*</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">m2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">product?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">x</span><span class="p">)</span> <span class="ss">'*</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplier</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">multiplicand</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddr </span><span class="nv">p</span><span class="p">))</span>
<span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">product?</span> <span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">multiplier</span> <span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">multiplicand</span> <span class="p">(</span><span class="nf">make-product</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>

<ul class="org-ul">
<li class="on">
<code>[X]</code> проблема становится сложнее если опустить необязательные скобки и подразумевать что умножение имеет приоритет над суммой, предложите свое решение для этого случая (x + 3 * (x + y + 2)) когда аргументов может быть более 2.</li>
</ul>
<p>
еще может быть вот такой случай (x + 3 * (x + y + 2) + (x * x)) тут после второй итерации нужно делать не умножение а ещё одну сумму.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="nv">op</span> <span class="nv">exp</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">exp</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">exp</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">eq? </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">exp</span><span class="p">)</span> <span class="nv">op</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="nv">op</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">exp</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-sum</span> <span class="nv">a1</span> <span class="nv">a2</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="nv">a1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'+</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">a2</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum?</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fop</span> <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="ss">'+</span> <span class="nv">s</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">&gt; </span><span class="nv">fop</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">addend</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">rev</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fop</span> <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="ss">'+</span> <span class="nv">rev</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nf">addends</span> <span class="p">()))</span>
      <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">ss</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	    <span class="nv">ss</span>
	    <span class="p">(</span><span class="nf">iter-shift</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">ss</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">define </span><span class="nv">addends</span> <span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">rev</span> <span class="nv">fop</span><span class="p">))</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">addends</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">car </span><span class="nv">addends</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">reverse </span><span class="nv">addends</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">augend</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">fop</span> <span class="p">(</span><span class="nf">search-first-operand-position</span> <span class="ss">'+</span> <span class="nv">s</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nf">aug</span> <span class="p">()))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">ss</span> <span class="nv">n</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	  <span class="nv">ss</span>
	  <span class="p">(</span><span class="nf">iter-shift</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">ss</span><span class="p">))</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">define </span><span class="nv">aug</span> <span class="p">(</span><span class="nf">iter-shift</span> <span class="nv">s</span> <span class="nv">fop</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">length </span><span class="nv">aug</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">car </span><span class="nv">aug</span><span class="p">)</span>
	<span class="nv">aug</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">deriv</span> <span class="o">'</span><span class="p">(</span><span class="nv">x</span> <span class="nv">+</span> <span class="mi">3</span> <span class="nv">*</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">+</span> <span class="nv">y</span> <span class="nv">+</span> <span class="mi">2</span><span class="p">))</span> <span class="ss">'x</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org3da3f3a" class="outline-2">
<h2 id="org3da3f3a">Упражнение 2.59</h2>
<div class="outline-text-2" id="text-org3da3f3a">
<p>
Определите процедуру union-set если set не отсортированный список.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span>
	<span class="p">((</span><span class="nf">element-of-set?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))))</span>
</pre></div>

<p>
так как все процедуры используют element-of-set? эта функция сильно влияет на порядок роста. Порядок роста для element-of-set? и adjoin-set равен n. Для intersection-set и union-set n<sup>2</sup>.
</p>
</div>
</div>

<div id="outline-container-org3876ac1" class="outline-2">
<h2 id="org3876ac1">Упражнение 2.60</h2>
<div class="outline-text-2" id="text-org3876ac1">
<p>
Предположим сеты могут иметь дубликаты. Реализуйте методы для сетов для такой структуры. Как от этого изменится порядок роста?
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">element-of-set?</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">equal? </span><span class="nv">x</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">))</span> <span class="nv">true</span><span class="p">)</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">element-of-set?</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">set</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">))</span> <span class="o">'</span><span class="p">())</span>
	<span class="p">((</span><span class="nf">element-of-set?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
	 <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">append </span><span class="nv">set1</span> <span class="nv">set2</span><span class="p">))</span>
</pre></div>

<p>
Для element-of-set порядок роста n, для adjoin-set 1, для intersection-set n<sup>2</sup>, для union-set n (так как append займет n).
</p>
</div>
</div>

<div id="outline-container-orgf2dfffc" class="outline-2">
<h2 id="orgf2dfffc">Упражнение 2.61</h2>
<div class="outline-text-2" id="text-orgf2dfffc">
<p>
Дайте определение adjoin-set для сортированных списков.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">))</span>
	<span class="p">((</span><span class="nb">= </span><span class="nv">x</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">))</span> <span class="nv">set</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">set</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set</span><span class="p">))))))</span>
</pre></div>
<p>
порядок роста по прежнему n, но иногда работает быстрее.
</p>
</div>
</div>

<div id="outline-container-org0e3766d" class="outline-2">
<h2 id="org0e3766d">Упражнение 2.62</h2>
<div class="outline-text-2" id="text-org0e3766d">
<p>
Приведите определение union-set с порядком роста n.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)))</span>
		<span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span>
			     <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span>
					<span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))</span>
		      <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span> <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
		      <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
		       <span class="p">(</span><span class="nb">cons </span><span class="nv">x2</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))))))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org2e59406" class="outline-2">
<h2 id="org2e59406">Упражнение 2.63</h2>
<div class="outline-text-2" id="text-org2e59406">
<p>
Обе процедуры приведенные ниже трансформируют дерево в список.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span>
      <span class="o">'</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">))</span>
	      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">)</span>
		    <span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">copy-to-list</span> <span class="nv">tree</span> <span class="nv">result-list</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span>
	<span class="nv">result-list</span>
	<span class="p">(</span><span class="nf">copy-to-list</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">)</span>
		      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">)</span>
			    <span class="p">(</span><span class="nf">copy-to-list</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)</span>
					  <span class="nv">result-list</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">copy-to-list</span> <span class="nv">tree</span> <span class="o">'</span><span class="p">()))</span>
</pre></div>

<p>
a. Будут ли отличаться результаты двух процедур? Какие списки будут для дерева с рисунка 2.16
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">tree1</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">7</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">3</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">1</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">5</span> <span class="p">()</span> <span class="p">()))</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">9</span>
				    <span class="p">()</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">11</span> <span class="p">()</span> <span class="p">()))))</span>

<span class="nv">tree1</span>
<span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree1</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">tree2</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">3</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">7</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">5</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">9</span>
					       <span class="p">()</span>
					       <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">11</span> <span class="p">()</span> <span class="p">())))</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">1</span>
				    <span class="p">()</span>
				    <span class="p">())))</span>

<span class="nv">tree2</span>
<span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree2</span><span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="nv">tree3</span> <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">5</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">3</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">1</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">())</span>
			 <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">9</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">7</span> <span class="p">()</span> <span class="p">())</span>
				    <span class="p">(</span><span class="nf">make-tree</span> <span class="mi">11</span> <span class="p">()</span> <span class="p">()))))</span>
<span class="nv">tree3</span>
<span class="p">(</span><span class="nf">tree-&gt;list-1</span> <span class="nv">tree3</span><span class="p">)</span>
<span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">tree3</span><span class="p">)</span>
</pre></div>

<p>
списки одинаковые
</p>

<p>
b. как отличается порядок роста?
в первом случае за счет линейного времени append, порядок роста n*log(n)
во втором случае порядок роста будет n.
</p>
</div>
</div>

<div id="outline-container-orgd3375d6" class="outline-2">
<h2 id="orgd3375d6">Упражнение 2.64</h2>
<div class="outline-text-2" id="text-orgd3375d6">
<p>
Следующая процедура list-&gt;tree преобразует отсортированный список в сбалансированное бинарное дерево. Вспомогательная процедура partial-tree принимает в качестве аргументов целое n и список и строит сбалансированное  бинарное дерево содержащее первые n элементов списка. Результат это функции - пара, первое значение это созданное дерево, а cdr элементы не вошедшие в дерево.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="nv">elements</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elements</span> <span class="p">(</span><span class="nb">length </span><span class="nv">elements</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elts</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="o">'</span><span class="p">()</span> <span class="nv">elts</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">left-size</span> <span class="p">(</span><span class="nb">quotient </span><span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">left-result</span> <span class="p">(</span><span class="nf">partial-tree</span> <span class="nv">elts</span> <span class="nv">left-size</span><span class="p">)))</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">left-tree</span> <span class="p">(</span><span class="nb">car </span><span class="nv">left-result</span><span class="p">))</span>
		<span class="p">(</span><span class="nf">non-left-elts</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">left-result</span><span class="p">))</span>
		<span class="p">(</span><span class="nf">right-size</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">left-size</span> <span class="mi">1</span><span class="p">))))</span>
	    <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">this-entry</span> <span class="p">(</span><span class="nb">car </span><span class="nv">non-left-elts</span><span class="p">))</span>
		  <span class="p">(</span><span class="nf">right-result</span> <span class="p">(</span><span class="nf">partial-tree</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">non-left-elts</span><span class="p">)</span>
					      <span class="nv">right-size</span><span class="p">)))</span>
	      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">right-tree</span> <span class="p">(</span><span class="nb">car </span><span class="nv">right-result</span><span class="p">))</span>
		    <span class="p">(</span><span class="nf">remaining-elts</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">right-result</span><span class="p">)))</span>
		<span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">make-tree</span> <span class="nv">this-entry</span> <span class="nv">left-tree</span> <span class="nv">right-tree</span><span class="p">)</span>
		      <span class="nv">remaining-elts</span><span class="p">))))))))</span>
</pre></div>

<p>
a. Кратко опишите как работает partial-tree. Нарисуйте дерево для списка (1 3 5 7 9 11).
</p>

<p>
Берем половину списка, строим от него дерево из первых int((n-1)/2 элементов. берем следующий элемент это будет вершина дерева, берем остальные элементы это будет правая часть дерева. для левой и правой стороны дерева процесс построения рекурсивно повторяется.
</p>

<div class="highlight"><pre><span></span><span class="c1">;Value: ((5 (1 () (3 () ())) (9 (7 () ()) (11 () ()))))</span>

	   <span class="mi">5</span>
	<span class="nv">/</span>      <span class="err">\</span>
       <span class="mi">1</span>         <span class="mi">9</span>
	<span class="err">\</span>       <span class="nv">/</span>  <span class="err">\</span>
     <span class="p">()</span>  <span class="mi">3</span>     <span class="mi">7</span>    <span class="mi">11</span>
	<span class="nv">/</span> <span class="err">\</span>   <span class="nv">/</span><span class="err">\</span>    <span class="nv">/</span> <span class="err">\</span>
       <span class="p">()</span> <span class="p">()</span> <span class="p">()()</span>  <span class="p">()</span>  <span class="p">()</span>
</pre></div>

<p>
b. Каков порядок роста list-&gt;tree?
</p>

<p>
Порядок роста n.
</p>
</div>
</div>

<div id="outline-container-orgc94bc7d" class="outline-2">
<h2 id="orgc94bc7d">Упражнение 2.65</h2>
<div class="outline-text-2" id="text-orgc94bc7d">
<p>
Используя результаты упражнений 2.63 и 2.64 приведите определение union-set и intersection-set для множеств определенных как сбалансированные бинарные деревья.
</p>

<div class="highlight"><pre><span></span>	<span class="mi">4</span>                     <span class="mi">7</span>
      <span class="nv">/</span>  <span class="err">\</span>                <span class="nv">/</span>      <span class="err">\</span>
     <span class="mi">3</span>    <span class="mi">5</span>              <span class="mi">1</span>         <span class="mi">9</span>
    <span class="nv">/</span> <span class="err">\</span>   <span class="nv">/</span> <span class="err">\</span>              <span class="err">\</span>       <span class="nv">/</span>  <span class="err">\</span>
  <span class="p">()</span>   <span class="mi">1</span> <span class="mi">6</span>   <span class="mi">11</span>         <span class="p">()</span>  <span class="mi">3</span>     <span class="mi">8</span>    <span class="mi">11</span>
			   <span class="nv">/</span> <span class="err">\</span>   <span class="nv">/</span><span class="err">\</span>    <span class="nv">/</span> <span class="err">\</span>
			  <span class="p">()</span> <span class="p">()</span> <span class="p">()()</span>  <span class="p">()</span>  <span class="p">()</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-tree-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">orderedlist1</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">orderedlist2</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set2</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)</span>
	    <span class="p">((</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">)</span> <span class="nv">set1</span><span class="p">)</span>
	    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)))</span>
		    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
			   <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span>
				 <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span>
					    <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))</span>
			  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
			   <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span> <span class="p">(</span><span class="nf">union-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">)))</span>
			  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
			   <span class="p">(</span><span class="nb">cons </span><span class="nv">x2</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))))))))</span>

    <span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="p">(</span><span class="nf">union-set</span> <span class="nv">orderedlist1</span> <span class="nv">orderedlist2</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intersection-tree-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">orderedlist1</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">orderedlist2</span> <span class="p">(</span><span class="nf">tree-&gt;list-2</span> <span class="nv">set2</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">set1</span> <span class="nv">set2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">set1</span><span class="p">)</span> <span class="p">(</span><span class="nb">null? </span><span class="nv">set2</span><span class="p">))</span>
	  <span class="o">'</span><span class="p">()</span>
	  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set1</span><span class="p">))</span> <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set2</span><span class="p">)))</span>
	    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nb">cons </span><span class="nv">x1</span>
			 <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span>
					   <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">))))</span>
		  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">intersection-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set1</span><span class="p">)</span> <span class="nv">set2</span><span class="p">))</span>
		  <span class="p">((</span><span class="nb">&lt; </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">set1</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set2</span><span class="p">)))))))</span>
    <span class="p">(</span><span class="nf">list-&gt;tree</span> <span class="p">(</span><span class="nf">intersection-set</span> <span class="nv">orderedlist1</span> <span class="nv">orderedlist2</span><span class="p">))))</span>
</pre></div>

<p>
так как tree-&gt;list-2, list-&gt;tree и intersection-set, union-set (на сортированных списках) имеют порядок роста n, то и последовательное применение этих алгоритмов также имеет такой же порядок роста.
</p>
</div>
</div>

<div id="outline-container-orgce19218" class="outline-2">
<h2 id="orgce19218">Упражнение 2.66</h2>
<div class="outline-text-2" id="text-orgce19218">
<p>
Определите lookup для бинарного дерева.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lookup</span> <span class="nv">given-key</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">tree</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">equal? </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span>
	<span class="p">((</span><span class="nb">&gt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)))</span>
	<span class="p">((</span><span class="nb">&lt; </span><span class="nv">given-key</span> <span class="p">(</span><span class="nf">entry</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">given-key</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">)))))</span>
</pre></div>

<p>
log n
</p>
</div>
</div>

<div id="outline-container-orge488258" class="outline-2">
<h2 id="orge488258">Упражнение 2.67</h2>
<div class="outline-text-2" id="text-orge488258">
<p>
Дано кодирующее дерево и сообщение, используя decode расшифруйте сообщение.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">sample-tree</span>
  <span class="p">(</span><span class="nf">make-code-tree</span> <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'A</span> <span class="mi">4</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">make-code-tree</span>
		   <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">make-code-tree</span> <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'D</span> <span class="mi">1</span><span class="p">)</span>
				   <span class="p">(</span><span class="nf">make-leaf</span> <span class="ss">'C</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">sample-message</span> <span class="o">'</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">decode</span> <span class="nv">sample-message</span> <span class="nv">sample-tree</span><span class="p">)</span>
<span class="c1">;Value: (a d a b b c a)</span>
</pre></div>
</div>
</div>

<div id="outline-container-orge6697ff" class="outline-2">
<h2 id="orge6697ff">Упражнение 2.68</h2>
<div class="outline-text-2" id="text-orge6697ff">
<p>
Процедура encode принимает на вход сообщение и дерево и генерирует последовательность бит.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="nv">symbols</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">symbols</span><span class="p">)</span>
      <span class="nv">false</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">symbol</span> <span class="p">(</span><span class="nb">car </span><span class="nv">symbols</span><span class="p">))</span>
	  <span class="nv">true</span>
	  <span class="p">(</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">symbols</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">in-list?</span> <span class="ss">'A</span> <span class="o">'</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">symbol</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">l-branch</span> <span class="p">(</span><span class="nf">left-branch</span> <span class="nv">tree</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">r-branch</span> <span class="p">(</span><span class="nf">right-branch</span> <span class="nv">tree</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="p">(</span><span class="nf">symbols</span> <span class="nv">l-branch</span><span class="p">))</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">l-branch</span><span class="p">)</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'0</span> <span class="p">())</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'0</span> <span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">symbol</span> <span class="nv">l-branch</span><span class="p">))))</span>
	  <span class="p">((</span><span class="nf">in-list?</span> <span class="nv">symbol</span> <span class="p">(</span><span class="nf">symbols</span> <span class="nv">r-branch</span><span class="p">))</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">leaf?</span> <span class="nv">r-branch</span><span class="p">)</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'1</span> <span class="p">())</span>
						    <span class="p">(</span><span class="nb">cons </span><span class="ss">'1</span> <span class="p">(</span><span class="nf">encode-symbol</span> <span class="nv">symbol</span> <span class="nv">r-branch</span><span class="p">))))</span>
	  <span class="p">(</span><span class="nf">else</span>
	   <span class="p">(</span><span class="nf">error</span> <span class="s">"not exist symbol -- ENCODE-SYMBOL"</span> <span class="nv">symbol</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">a</span> <span class="nv">d</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">sample-tree</span><span class="p">)</span> <span class="c1">;Value: (0 1 1 0 0 1 0 1 0 1 1 1 0)</span>
</pre></div>

<p>
Encode-symbol - процедура кодирующая один символ. Дайте определение этой процедуры. Протестируйте на результате упражнения 2.67.
</p>
</div>
</div>

<div id="outline-container-org6356635" class="outline-2">
<h2 id="org6356635">Упражнение 2.69</h2>
<div class="outline-text-2" id="text-org6356635">
<p>
Следующая процедура генерирует дерево по Хафману из пар символ-частота.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">successive-merge</span> <span class="p">(</span><span class="nf">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)))</span>
</pre></div>

<p>
Make-leaf-set, процедура приведенная выше, сортирует пары. Нужно дать определение процедуры successive-merge, которая делает слияние элементов с наименьшим весом, пока не останется один элемент.
</p>

<div class="highlight"><pre><span></span><span class="c1">;; вставка отсортированная по весу</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="nv">set</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">null? </span><span class="nv">set</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">x</span><span class="p">))</span>
	<span class="p">((</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">weight</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">weight</span> <span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">)))</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">set</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">set</span><span class="p">)</span>
		    <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">set</span><span class="p">))))))</span>

<span class="c1">;; получаем сортированный список листов.</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">pairs</span><span class="p">)</span>
      <span class="o">'</span><span class="p">()</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">pair</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pairs</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">adjoin-set</span> <span class="p">(</span><span class="nf">make-leaf</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span>    <span class="c1">; symbol</span>
			       <span class="p">(</span><span class="nb">cadr </span><span class="nv">pair</span><span class="p">))</span>  <span class="c1">; frequency</span>
		    <span class="p">(</span><span class="nf">make-leaf-set</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pairs</span><span class="p">))))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">successive-merge</span> <span class="nv">opairs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">length </span><span class="nv">opairs</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">car </span><span class="nv">opairs</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">merged</span> <span class="p">(</span><span class="nf">make-code-tree</span> <span class="p">(</span><span class="nb">car </span><span class="nv">opairs</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">opairs</span><span class="p">))))</span>
	<span class="p">(</span><span class="nb">display </span><span class="nv">merged</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">newline</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">successive-merge</span> <span class="p">(</span><span class="nf">adjoin-set</span> <span class="nv">merged</span> <span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">opairs</span><span class="p">)))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">successive-merge</span> <span class="p">(</span><span class="nf">make-leaf-set</span> <span class="nv">pairs</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">gentree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'C</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'D</span> <span class="mi">1</span><span class="p">))))</span>
<span class="nv">gentree</span>
<span class="p">(</span><span class="nf">symbols</span> <span class="nv">gentree</span><span class="p">)</span>

<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">a</span> <span class="nv">d</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">gentree</span><span class="p">)</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgea6f2c7" class="outline-2">
<h2 id="orgea6f2c7">Упражнение 2.70</h2>
<div class="outline-text-2" id="text-orgea6f2c7">
<p>
Следующий 8ми символьный алфавит с заданными частотами повторения был разработан чтобы эффективно кодировать рок лирику пятидесятых.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-left">
<col class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">2</td>
<td class="org-left">NA</td>
<td class="org-right">16</td>
</tr>
<tr>
<td class="org-left">BOOM</td>
<td class="org-right">1</td>
<td class="org-left">SHA</td>
<td class="org-right">3</td>
</tr>
<tr>
<td class="org-left">GET</td>
<td class="org-right">2</td>
<td class="org-left">YIP</td>
<td class="org-right">9</td>
</tr>
<tr>
<td class="org-left">JOB</td>
<td class="org-right">2</td>
<td class="org-left">WAH</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<p>
Get a job
</p>

<p>
Sha na na na na na na na na
</p>

<p>
Get a job
</p>

<p>
Sha na na na na na na na na
</p>

<p>
Wah yip yip yip yip yip yip yip yip yip
</p>

<p>
Sha boom
</p>

<p>
Сколько бит потребуется для кодирования?
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">pairs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'BOOM</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'GET</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'JOB</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'NA</span> <span class="mi">16</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'SHA</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'YIP</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'WAH</span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">lyric-tree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">song</span> <span class="o">'</span><span class="p">(</span><span class="nv">Get</span> <span class="nv">a</span> <span class="nv">job</span> <span class="nv">Sha</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">Get</span> <span class="nv">a</span> <span class="nv">job</span> <span class="nv">Sha</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">na</span> <span class="nv">Wah</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">yip</span> <span class="nv">Sha</span> <span class="nv">boom</span><span class="p">))</span>
<span class="nv">song</span>

<span class="p">(</span><span class="nb">length </span><span class="p">(</span><span class="nf">encode</span> <span class="nv">song</span> <span class="nv">lyric-tree</span><span class="p">))</span>
<span class="c1">;; 84</span>

<span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nb">length </span><span class="nv">song</span><span class="p">))</span>

<span class="c1">;; 108</span>
<span class="c1">;; 22.333%</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgcf50e46" class="outline-2">
<h2 id="orgcf50e46">Упражнение 2.71</h2>
<div class="outline-text-2" id="text-orgcf50e46">
<p>
Предположим у нас есть дерево по Хафману для алфавита из n символов, частота которых 1,2,4,..,2<sup>(n-1)</sup>. Сделайте набросок дерева для n=5 и n=10. Сколько бит требуется в таком дереве что бы закодировать наиболее часто встречающийся символ? Наименее часто встречающийся?
</p>

<div class="highlight"><pre><span></span><span class="c1">;; n = 5</span>
<span class="c1">;; 1,2,4,8,16</span>
<span class="c1">;; (1,2, 3)</span>
<span class="c1">;; (1,2,4 7)</span>
<span class="c1">;; (1,2,4,8 15)</span>
<span class="c1">;; (1,2,4,8,16 31)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pairs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'D</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'E</span> <span class="mi">16</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">bin-tree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">))</span>
<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="nv">bin-tree</span><span class="p">)</span>
<span class="c1">;; (0 0 0 0)</span>


<span class="c1">;; (1,2,4,8,16,32 63)</span>

<span class="c1">;; n = 10</span>
<span class="c1">;; 1,2,4,8,16</span>
<span class="c1">;; (1,2, 3)</span>
<span class="c1">;; (1,2,4 7)</span>
<span class="c1">;; (1,2,4,8 15)</span>
<span class="c1">;; (1,2,4,8,16 31)</span>
<span class="c1">;; (1,2,4,8,16,32 63)</span>
<span class="c1">;; (1,2,4,8,16,32,64 127)</span>
<span class="c1">;; (1,2,4,8,16,32,64,128 255)</span>
<span class="c1">;; (1,2,4,8,16,32,64,128,256 511)</span>
<span class="c1">;; (1,2,4,8,16,32,64,128,256,512 1023)</span>

<span class="c1">;; чтобы закодировать самый частый символ 1 бит</span>
<span class="c1">;; чтобы закодировать самый редкий символ для n=5, </span>

<span class="c1">;; 1,2,4,8,16,32,64,128,256,512</span>
<span class="p">(</span><span class="k">define </span><span class="nv">pairs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">list </span><span class="ss">'A</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'C</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'D</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'E</span> <span class="mi">16</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'F</span> <span class="mi">32</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'G</span> <span class="mi">64</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'H</span> <span class="mi">128</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'I</span> <span class="mi">256</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="ss">'J</span> <span class="mi">512</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">bin-tree</span> <span class="p">(</span><span class="nf">generate-huffman-tree</span> <span class="nv">pairs</span><span class="p">))</span>
<span class="nv">bin-tree</span>
<span class="p">(</span><span class="nf">encode</span> <span class="o">'</span><span class="p">(</span><span class="nv">A</span><span class="p">)</span> <span class="nv">bin-tree</span><span class="p">)</span>
<span class="c1">;; (0 0 0 0 0 0 0 0 0)</span>


		     <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span> <span class="mi">31</span>
		     <span class="nv">/</span>           <span class="err">\</span>
		<span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">15</span>      <span class="nv">e</span> <span class="mi">16</span>
		 <span class="nv">/</span>     <span class="err">\</span>
	   <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">7</span>    <span class="nv">d</span> <span class="mi">8</span>
	     <span class="nv">/</span>    <span class="err">\</span>
	<span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">3</span>    <span class="nv">c</span> <span class="mi">4</span>
	 <span class="nv">/</span>   <span class="err">\</span>
      <span class="nv">a</span> <span class="mi">1</span>    <span class="nv">b</span> <span class="mi">2</span>
<span class="c1">;; получается n-1 бит</span>
</pre></div>
</div>
</div>


<div id="outline-container-orgc413929" class="outline-2">
<h2 id="orgc413929">Упражнение 2.72</h2>
<div class="outline-text-2" id="text-orgc413929">
<p>
Каков порядок роста для процедуры кодирования символа? Убедитесь что учли поиск вхождения символа. Ответить на этот вопрос в общем сложно. Поэтому рассмотрите частный случай когда частота символов при кодировании будет как в упражнении 2.71. И приведите порядок роста для кодирования наиболее часто встречающегося символа и наименее часто встречающегося символа.
</p>

<p>
для самого частого символа, нам нужно всего один раз проверить что символ встретился в алфавите, то есть порядок роста будет равен порядку роста поиска элемента в отсортированном списке, у нас это n (так как бинарное дерево не используется).
</p>

<p>
для самого редко встречающегося символа нам потребуется n -1 раз делать поиск по (n-1)/2 элементам то есть итоговый порядок роста будет n<sup>2</sup></p>

<p>
То есть общий ответ будет между n и n<sup>2</sup>.
</p>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/scheme/" rel="tag">scheme</a></li>
            <li><a class="tag p-category" href="../../categories/sicp/" rel="tag">sicp</a></li>
            <li><a class="tag p-category" href="../../categories/symbolic_data/" rel="tag">symbolic_data</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../sicp-224-primer-iazyk-izobrazhenii/" rel="prev" title="SICP 2.2.4 Пример: Язык изображений.">Предыдущая запись</a>
            </li>
            <li class="next">
                <a href="../sicp-24-mnozhestvennye-predstavleniia-dlia-abstraktnykh-dannykh/" rel="next" title="SICP 2.4 Множественные представления для абстрактных данных.">Следующая запись</a>
            </li>
        </ul></nav></aside></article></main><footer id="footer"><p>Contents © 2021         <a href="mailto:anton.s.pilipenko@gmail.com">Velikii Nehochuha</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
                <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
