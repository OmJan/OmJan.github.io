#+BEGIN_COMMENT
.. title: SICP Упражнения из главы 1.2 (1.9-1.12)
.. slug: sicp-uprazhneniia-iz-glavy-12
.. date: 2020-01-10 12:33:18 UTC+03:00
.. tags: sicp, scheme, lisp
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT


* Exercise 1.9.
Каждая из двух приведенных процедур реализует сложение в терминах инкремента (int), используя модель замещения, проиллюстрируйте процесс вычисления, это рекурсивные или итеративные процессы?

#+BEGIN_SRC scheme

(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(+ 6 5)
(inc (+ 5 5))
(inc (inc (+ 4 5)))
(inc (inc (inc (+ 3 5))))
(inc (inc (inc (inc (+ 2 5)))))
(inc (inc (inc (inc (inc (+ 1 5))))))
(inc (inc (inc (inc (inc (inc (+ 0 5))))))) ; 5 + 6inc 11


(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
(+ 6 5)
(+ 5 6)
(+ 4 7)
(+ 3 8)
(+ 2 9)
(+ 1 10)
(+ 0 11) ; 11
#+END_SRC

* Exercise 1.10
Функция Аккермана. Интересна тем что являетеся рекурсивной и растет быстрее экспоненты.
#+BEGIN_SRC scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
(A 1 10) ;Value: 1024
(A 2 4) ;Value: 65536
(A 3 3) ;Value: 65536
#+END_SRC
Рассмотрим следующие процедуры
#+BEGIN_SRC scheme
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
#+END_SRC

Дайте краткое математическое определение функций f, g, h. К примеру k(n) = 5*n*n

(f n) = (A 0 n) = (* 2 n)
(g n) = (A 1 n) = (A 0 (A 1 (- n 1))) = (* 2 (A 1 (- n 1))) = это будет 2 в степени n
(h n) = (A 2 n) = (A 1 (A 2 (- n 1))) = 2 в степени (A 2 (- n 1)) = 2 ** 2 в cтепени (A 2 (-n 2), пока A 2 (- n (- n 1))
(A 2 4) ;;  = 2 ** 2 ** 2 ** 2 ;; 65536

* Exercise 1.11.
Функция f(n) = n, если n<3 и f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) если n>= 3. Напишите процедуру для вычисления значения f в рекурсивной и итеративной форме.
#+BEGIN_SRC scheme
(define (f n)
  (cond ((< n 3) n)
        ((>= n 3) (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))))
#+END_SRC

при итеративном подходе просто начинаем с известных f(2) f(1) f(0) это параметры f-iter a, b, c
f(3) = (f(2) + 2f(1) + 3f(0)), записываем это значение в a
в b записываем f(2) в с f(1)
на следующей итерации нам вычислять f(4) = (f(3) + 2(f2) + 3(f1))
в a у нас f(3) b = f(2) c = f(1)то есть можем вычислить f4 и записать его в снова в a, при этом в b записываем f(3) то есть предыдущее значение a, в c записываем f(2) теперь нам нужно вычислить f(5), у нас все есть a = f(4) b = f(3) c = f(2).
#+BEGIN_SRC scheme
(define (f n)
   (define (f-iter a b c count)
     (if (< count 3)
         a
         (f-iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))
   (if (< n 3)
       n
       (f-iter 2 1 0 n)))
#+END_SRC

* Exercise 1.12.
Треугольник Паскаля изображен на картинке.
[[img-url:/images/ch1-Z-G-17.gif]]
Напишите рекурсивную процедуру вычисления значений элементов в треугольнике паскаля.

пусть n ряд в треугольнике
m - позиция в ряду начиная с 0, тогда значение в m будет равно биномиальному коэффициенту С из n по m. (/ n! (* m! (- n m)!)
(1 + x)**3 = 1 + 3x + 3xx + xxx
#+BEGIN_SRC scheme
;; через биномиальные коэффициенты
(define (factorial n)
  (if (= n 1)
      n
      (* n (factorial (- n 1)))))
(define (pascal n m)
  (if (or (= n 0) (= m n) (= m 0))
      1
      (/ (factorial n) (* (factorial m) (- n m)))))

;; рекурсивно поднимамясь вверх по столбцам
(define (pascal n m)
  (cond ((or (= m 0) (= m n)) 1)
        (else (+ (pascal (- n 1) (- m 1))
                 (pascal (- n 1) m)))))
#+END_SRC

