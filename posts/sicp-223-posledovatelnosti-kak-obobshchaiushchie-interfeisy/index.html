<!DOCTYPE html>
<html prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>SICP 2.2.3 Последовательности как обобщающие интерфейсы. | VelikiiNehochuha Blog</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="../../rss.xml">
<link rel="canonical" href="http://velikiinehochuha.github.io/posts/sicp-223-posledovatelnosti-kak-obobshchaiushchie-interfeisy/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Velikii Nehochuha">
<link rel="prev" href="../sicp-22-ierarkhicheskie-dannye-i-svoistvo-zamykaniia-the-closure-property/" title="SICP 2.2 Иерархические данные и свойство замыкания (the closure property)." type="text/html">
<link rel="next" href="../sicp-224-primer-iazyk-izobrazhenii/" title="SICP 2.2.4 Пример: Язык изображений." type="text/html">
<meta property="og:site_name" content="VelikiiNehochuha Blog">
<meta property="og:title" content="SICP 2.2.3 Последовательности как обобщающие интерфейсы.">
<meta property="og:url" content="http://velikiinehochuha.github.io/posts/sicp-223-posledovatelnosti-kak-obobshchaiushchie-interfeisy/">
<meta property="og:description" content="Упражнение 2.33


Заполните недостающие выражения, чтобы завершить определения некоторых основных операций над списками через накопление.


(define (map p sequence)
  (accumulate (lambda (x y) &lt;??&gt;) n">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-01-20T14:08:28+03:00">
<meta property="article:tag" content="scheme">
<meta property="article:tag" content="sequences_as_conventional_interfaces">
<meta property="article:tag" content="sicp">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="../../" title="VelikiiNehochuha Blog" rel="home">

        <span id="blog-title">VelikiiNehochuha Blog</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="../../archive.html">Архив</a></li>
                <li><a href="../../categories/">Тэги</a></li>
                <li><a href="../../rss.xml">RSS лента</a></li>

    
    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">SICP 2.2.3 Последовательности как обобщающие интерфейсы.</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Velikii Nehochuha
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2020-01-20T14:08:28+03:00" itemprop="datePublished" title="2020-01-20 14:08">2020-01-20 14:08</time></a>
            </p>
                    <p class="sourceline"><a href="index.org" class="sourcelink">Источник</a></p>

        </div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>
<img src="../../images/ch2-Z-G-17.gif" alt="nil"></p>


<div id="outline-container-orgcfefae3" class="outline-2">
<h2 id="orgcfefae3">Упражнение 2.33</h2>
<div class="outline-text-2" id="text-orgcfefae3">
<p>
Заполните недостающие выражения, чтобы завершить определения некоторых основных операций над списками через накопление.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">map </span><span class="nv">p</span> <span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">&lt;??&gt;</span><span class="p">)</span> <span class="nv">nil</span> <span class="nv">sequence</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">append </span><span class="nv">seq1</span> <span class="nv">seq2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">cons</span> <span class="nv">&lt;??&gt;</span> <span class="nv">&lt;??&gt;</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">length </span><span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">&lt;??&gt;</span> <span class="mi">0</span> <span class="nv">sequence</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">map </span><span class="nv">p</span> <span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">p</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">nil</span> <span class="nv">sequence</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">append </span><span class="nv">seq1</span> <span class="nv">seq2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">cons</span> <span class="nv">seq2</span> <span class="nv">seq1</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">length </span><span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">0</span> <span class="nv">sequence</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org385d612" class="outline-2">
<h2 id="org385d612">Упражнение 2.34</h2>
<div class="outline-text-2" id="text-org385d612">
<p>
Оценка полинома от одной переменной x в заданной точке, может быть сформулирована в терминах накопления. Мы оцениваем полином
\(a_nx^n+a_{n-1}x^{n-1}+...+a_1x+a_0x\) используя широко известный алгоритм - правило Хорнера, который структурирует вычисление как \((...(a_nx+a_{n-1})x+...+a_1)x + a_0\).
</p>

<p>
Другими словами начиная с a<sub>n</sub> умноженного на x, добавляем a<sub>n-1</sub>, умножаем на x и так далее, пока не достигаем a<sub>0</sub>. Заполните шаблон что бы закончить процедуру вычисления полинома, предполагая что коэффициенты полинома заданы списком.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">horner-eval</span> <span class="nv">x</span> <span class="nv">coefficient-sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">this-coeff</span> <span class="nv">higher-terms</span><span class="p">)</span> <span class="nv">&lt;??&gt;</span><span class="p">)</span>
	      <span class="mi">0</span>
	      <span class="nv">coefficient-sequence</span><span class="p">))</span>
<span class="p">(</span><span class="nf">horner-eval</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">0</span> <span class="mi">5</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">horner-eval</span> <span class="nv">x</span> <span class="nv">coefficient-sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">this-coeff</span> <span class="nv">higher-terms</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">this-coeff</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">higher-terms</span><span class="p">)))</span>
	      <span class="mi">0</span>
	      <span class="nv">coefficient-sequence</span><span class="p">))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org780594a" class="outline-2">
<h2 id="org780594a">Упражнение 2.35</h2>
<div class="outline-text-2" id="text-org780594a">
<p>
Переопределите count-leaves из секции 2.2.2 через накопление.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">count-leaves</span> <span class="nv">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">&lt;??&gt;</span> <span class="nv">&lt;??&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="nv">&lt;??&gt;</span> <span class="nv">&lt;??&gt;</span><span class="p">)))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">count-leaves</span> <span class="nv">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">+</span> <span class="mi">0</span>
	      <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">sub-tree</span><span class="p">)</span>
		     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">sub-tree</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">count-leaves</span> <span class="nv">sub-tree</span><span class="p">)</span>
			 <span class="mi">1</span><span class="p">))</span> <span class="nv">t</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orge9f19c7" class="outline-2">
<h2 id="orge9f19c7">Упражнение 2.36</h2>
<div class="outline-text-2" id="text-orge9f19c7">
<p>
Процедура accumulate-n похожа на accumulate, но принимает третий аргумент последовательность последовательностей. Предполагается что все они имеют одинаковое количество аргументов. Она применяет назначенную процедуру накопления для всех первых элементов последовательности, всех вторых и так далее. И возвращает последовательность результатов. К примеру результат (accumulate-n + 0 s), где s это ((1 2 3) (4 5 6) (7 8 9) (10 11 12)), будет равен (22 26 30). Заполните пропуски в определении процедуры.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">accumulate-n</span> <span class="nv">op</span> <span class="nv">init</span> <span class="nv">seqs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">car </span><span class="nv">seqs</span><span class="p">))</span>
      <span class="nv">nil</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">accumulate</span> <span class="nv">op</span> <span class="nv">init</span> <span class="nv">&lt;??&gt;</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">accumulate-n</span> <span class="nv">op</span> <span class="nv">init</span> <span class="nv">&lt;??&gt;</span><span class="p">))))</span>
</pre></div>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">accumulate-n</span> <span class="nv">op</span> <span class="nv">init</span> <span class="nv">seqs</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">car </span><span class="nv">seqs</span><span class="p">))</span>
      <span class="nv">nil</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">accumulate</span> <span class="nv">op</span> <span class="nv">init</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">seq</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">seq</span><span class="p">))</span> <span class="nv">seqs</span><span class="p">))</span>
	    <span class="p">(</span><span class="nf">accumulate-n</span> <span class="nv">op</span> <span class="nv">init</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">seq</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">seq</span><span class="p">))</span> <span class="nv">seqs</span><span class="p">)))))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org17b749c" class="outline-2">
<h2 id="org17b749c">Упражнение 2.37</h2>
<div class="outline-text-2" id="text-org17b749c">
<p>
Предположим мы представляем векторы v = (v<sub>i</sub>) как последовательность чисел и матрицы m =(m<sub>ij</sub>) как последовательность векторов (строки матрицы). К примеру матрица:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="org-left"></colgroup>
<tbody>
<tr>
<td class="org-left">1 2 3 4</td>
</tr>
<tr>
<td class="org-left">4 5 6 7</td>
</tr>
<tr>
<td class="org-left">6 7 8 9</td>
</tr>
</tbody>
</table>
<p>
представлена как последовательность ((1 2 3 4) (4 5 6 6) (6 7 8 9)).
C этим представлением мы можем использовать последовательности операций чтобы выразить основные операции на матрицей и вектором. Эти операции (которые описаны в любой книжке по алгебре) следующие:
</p>

<p>
(dot-product v w)
(matrix-<b>-vector m v)
(matrix-</b>-matrix m n)
(transpose m) ;; вернет матрицу n, где n<sub>ij</sub> = m<sub>ji</sub></p>


<p>
Мы можем определить dot-product как (map - стандартный из scheme):
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dot-product</span> <span class="nv">v</span> <span class="nv">w</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">+</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">map </span><span class="nv">*</span> <span class="nv">v</span> <span class="nv">w</span><span class="p">)))</span>
</pre></div>

<p>
Заполните недостающие места в следующих процедурах для остальных операций над матрицами. (Процедура accumulate-n определена в упражнении 2.36)
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">matrix-*-vector</span> <span class="nv">m</span> <span class="nv">v</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">w</span><span class="p">)</span> <span class="p">(</span><span class="nf">dot-product</span> <span class="nv">w</span> <span class="nv">v</span><span class="p">))</span> <span class="nv">m</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">transpose</span> <span class="nv">mat</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate-n</span> <span class="nv">cons</span> <span class="p">()</span> <span class="nv">mat</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">matrix-*-matrix</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">cols</span> <span class="p">(</span><span class="nf">transpose</span> <span class="nv">n</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">row</span><span class="p">)</span> <span class="p">(</span><span class="nf">matrix-*-vector</span> <span class="nv">cols</span> <span class="nv">row</span><span class="p">))</span> <span class="nv">m</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org443d7cd" class="outline-2">
<h2 id="org443d7cd">Упражнение 2.38</h2>
<div class="outline-text-2" id="text-org443d7cd">
<p>
Процедура accumulate так же известна как fold-right, потому что она объединяет первый элемент последовательности с результатами объединения всех элементов справа. Также есть fold-left, которая объединяет элементы в обратном направлении.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fold-left</span> <span class="nv">op</span> <span class="nv">initial</span> <span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">iter</span> <span class="nv">result</span> <span class="nv">rest</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">rest</span><span class="p">)</span>
	<span class="nv">result</span>
	<span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nf">op</span> <span class="nv">result</span> <span class="p">(</span><span class="nb">car </span><span class="nv">rest</span><span class="p">))</span>
	      <span class="p">(</span><span class="nb">cdr </span><span class="nv">rest</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">initial</span> <span class="nv">sequence</span><span class="p">))</span>

<span class="c1">;; Каковы значения выражений?</span>
<span class="p">(</span><span class="nf">fold-right</span> <span class="nv">/</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">;; 3/2</span>
<span class="p">(</span><span class="nf">fold-left</span> <span class="nv">/</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">;;  1/6</span>
<span class="p">(</span><span class="nf">fold-right</span> <span class="nv">list</span> <span class="nv">nil</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span><span class="c1">;; (list 1 (list 2 ( list 3 ())))</span>
<span class="p">(</span><span class="nf">fold-left</span> <span class="nv">list</span> <span class="nv">nil</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">;; (list (list (list () 1) 2) 3)</span>
</pre></div>

<p>
Каким свойством должен обладать op что бы fold-right, fold-left были одинаковыми? Коммутативность и ассоциативность.
</p>
</div>
</div>

<div id="outline-container-org947a9aa" class="outline-2">
<h2 id="org947a9aa">Упражнение 2.39</h2>
<div class="outline-text-2" id="text-org947a9aa">
<p>
Дайте определение reverse через fold-right и fold-left.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">reverse </span><span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fold-right</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">first</span> <span class="nv">part-reversed</span><span class="p">)</span> <span class="p">(</span><span class="nb">append </span><span class="nv">part-reversed</span> <span class="p">(</span><span class="nb">list </span><span class="nv">first</span><span class="p">)))</span> <span class="nv">nil</span> <span class="nv">sequence</span><span class="p">))</span>
<span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">reverse </span><span class="nv">sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fold-left</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">result</span> <span class="nv">last</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">last</span> <span class="nv">result</span><span class="p">))</span> <span class="nv">nil</span> <span class="nv">sequence</span><span class="p">))</span>
</pre></div>
</div>
</div>


<div id="outline-container-org03170d4" class="outline-2">
<h2 id="org03170d4">Упражнение 2.40</h2>
<div class="outline-text-2" id="text-org03170d4">
<p>
Определите процедуру unique-pairs, которая принимая целое n, генерирует последовательность пар (i,j) 1&lt;=j&lt;i&lt;=n. Используя процедуру unique-pairs упростите определение prime-sum-pairs, приведенное в книге.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">unique-pairs</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">flatmap</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">i</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">j</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="nv">i</span> <span class="nv">j</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">- </span><span class="nv">i</span> <span class="mi">1</span><span class="p">))))</span>
   <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">prime-sum-pairs</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map </span><span class="nv">make-pair-sum</span>
       <span class="p">(</span><span class="nf">filter</span> <span class="nv">prime-sum?</span>
	       <span class="p">(</span><span class="nf">unique-pairs</span> <span class="nv">n</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">prime-sum-pairs</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org788a709" class="outline-2">
<h2 id="org788a709">Упражнение 2.41</h2>
<div class="outline-text-2" id="text-org788a709">
<p>
Напишите процедуру, чтобы найти все упорядоченные тройки различных положительных целых чисел i, j, k, меньших или равных заданному числу n, сумма которых равна заданному числу S.
</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">not-end-with-1?</span> <span class="nv">pair</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">pair</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">uniq-3</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">flatmap</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pair</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">car </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr </span><span class="nv">pair</span><span class="p">)</span> <span class="nv">k</span><span class="p">))</span>
	  <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">cadr </span><span class="nv">pair</span><span class="p">)</span> <span class="mi">1</span><span class="p">))))</span>
   <span class="p">(</span><span class="nf">filter</span> <span class="nv">not-end-with-1?</span> <span class="p">(</span><span class="nf">unique-pairs</span> <span class="nv">n</span><span class="p">))))</span>


<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">uniq-tuples-m</span> <span class="nv">n</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">nil</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">= </span><span class="nv">m</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="nv">list</span> <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">)))</span>
	<span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">flatmap</span>
	       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">tuple</span><span class="p">)</span>
		 <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">k</span> <span class="nv">tuple</span><span class="p">))</span>
		      <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">tuple</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
	       <span class="p">(</span><span class="nf">uniq-tuples-m</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">m</span> <span class="mi">1</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">uniq-tuples-m</span> <span class="mi">5</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6b2854d" class="outline-2">
<h2 id="org6b2854d">Упражнение 2.42</h2>
<div class="outline-text-2" id="text-org6b2854d">
<p>
Задача о восьми ферзях. Как разместить 8 ферзей на шахматной доске, что бы не один ферзь не бил другого. Одно из возможных решений представлено на картинке.
</p>

<p>
<img src="../../images/ch2-Z-G-23.gif" alt="nil"></p>

<p>
Один способ решения ставим первого ферзя на любую клетку доски. Остальные k-1 ферзей мы должны расставить так что бы они не атаковали друг друга. Можно сформулировать этот подход рекурсивно. Предположим мы уже генерировали всех возможные способы расстановки k-1 ферзей в первых k-1 столбцах доски. Для каждого из этих способов генерируем дополнительный набор позиций размещая ферзя в каждой строчке k-ой колонки. Теперь отфильтруем их оставляя только позиции в которых ферзь не атакован другими. Это даст все возможные расположения k ферзей в первых k колонках. Продолжая этот процесс мы получим решения головоломки.
</p>

<p>
Мы записали эту процедуру под именем queens. Она возвращает список всех решений для досок n x n. Она содержит внутреннюю процедуру queen-cols, которая возвращает список всех способов разместить ферзей на первых k колонках доски.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">queens</span> <span class="nv">board-size</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">list </span><span class="nv">empty-board</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">filter</span>
	 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">positions</span><span class="p">)</span> <span class="p">(</span><span class="nf">safe?</span> <span class="nv">k</span> <span class="nv">positions</span><span class="p">))</span>
	 <span class="p">(</span><span class="nf">flatmap</span>
	  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rest-of-queens</span><span class="p">)</span>
	    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">new-row</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">))</span>
		 <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="nv">board-size</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nf">queen-cols</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">board-size</span><span class="p">))</span>
</pre></div>

<p>
rest-of-queens - способ разместить k -1 ферзей в первых k - 1 колонках и new-row - строчка в которой надо поместить ферзя в k-ой колонке.
Завершите программу реализовав представление позиций, включая adjoin-position, которая добавляет новую позицию к существующим позициям, и empty-set - пустой список позиций. Также нужно написать процедуру safe?.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">empty-board</span> <span class="p">())</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">new-row</span> <span class="nv">rest-of-queens</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">include-row?</span> <span class="nv">item</span> <span class="nv">positions</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">positions</span><span class="p">)</span>
      <span class="nv">false</span>
      <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">item</span> <span class="p">(</span><span class="nb">car </span><span class="nv">positions</span><span class="p">))</span> <span class="p">(</span><span class="nf">include?</span> <span class="nv">item</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">positions</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">include-diagonale?</span> <span class="nv">item</span> <span class="nv">positions</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">positive</span> <span class="nv">item</span> <span class="nv">positions</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">positions</span><span class="p">)</span>
	<span class="nv">false</span>
	<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">+ </span><span class="nv">item</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">positions</span><span class="p">))</span> <span class="p">(</span><span class="nf">positive</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">item</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">positions</span><span class="p">)</span> <span class="nv">k</span><span class="p">))</span>
	<span class="p">))</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">negative</span> <span class="nv">item</span> <span class="nv">positions</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">null? </span><span class="nv">positions</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">- </span><span class="nv">item</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
	<span class="nv">false</span>
	<span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">- </span><span class="nv">item</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">positions</span><span class="p">))</span> <span class="p">(</span><span class="nf">negative</span> <span class="p">(</span><span class="nb">- </span><span class="nv">item</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">positions</span><span class="p">)</span> <span class="nv">k</span><span class="p">))</span>
	<span class="p">))</span>
  <span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="nf">negative</span> <span class="nv">item</span> <span class="nv">positions</span> <span class="nv">k</span><span class="p">)</span> <span class="p">(</span><span class="nf">positive</span> <span class="nv">item</span> <span class="nv">positions</span> <span class="nv">k</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">safe?</span> <span class="nv">k</span> <span class="nv">positions</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">and</span>
   <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">include-row?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">positions</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">positions</span><span class="p">)))</span> <span class="c1">;; нет совпадений по строкам</span>
   <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">include-diagonale?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">positions</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">positions</span><span class="p">)</span> <span class="nv">k</span><span class="p">))))</span> <span class="c1">;; не совпадает по диагоналям</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">queens</span> <span class="nv">board-size</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">k</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">k</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">(</span><span class="nb">list </span><span class="nv">empty-board</span><span class="p">)</span>
	<span class="p">(</span><span class="nf">filter</span>
	 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">positions</span><span class="p">)</span> <span class="p">(</span><span class="nf">safe?</span> <span class="nv">k</span> <span class="nv">positions</span><span class="p">))</span>
	 <span class="p">(</span><span class="nf">flatmap</span>
	  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rest-of-queens</span><span class="p">)</span>
	    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">new-row</span><span class="p">)</span>
		   <span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">))</span>
		 <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="nv">board-size</span><span class="p">)))</span>
	  <span class="p">(</span><span class="nf">queen-cols</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">queen-cols</span> <span class="nv">board-size</span><span class="p">))</span>

<span class="p">(</span><span class="nf">queens</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">;; Value: ((4 2 7 3 6 8 5 1) (5 2 4 7 3 8 6 1) (3 5 2 8 6 4 7 1) (3 6 4 2 8 5 7 1) (5 7 1 3 8 6 4 2) (4 6 8 3 1 7 5 2) (3 6 8 1 4 7 5 2) (5 3 8 4 7 1 6 2) (5 7 4 1 3 8 6 2) (4 1 5 8 6 3 7 2) (3 6 4 1 8 5 7 2) (4 7 5 3 1 6 8 2) (6 4 2 8 5 7 1 3) (6 4 7 1 8 2 5 3) (1 7 4 6 8 2 5 3) (6 8 2 4 1 7 5 3) (6 2 7 1 4 8 5 3) (4 7 1 8 5 2 6 3) (5 8 4 1 7 2 6 3) (4 8 1 5 7 2 6 3) (2 7 5 8 1 4 6 3) (1 7 5 8 2 4 6 3) (2 5 7 4 1 8 6 3) (4 2 7 5 1 8 6 3) (5 7 1 4 2 8 6 3) (6 4 1 5 8 2 7 3) (5 1 4 6 8 2 7 3) (5 2 6 1 7 4 8 3) (6 3 7 2 8 5 1 4) (2 7 3 6 8 5 1 4) (7 3 1 6 8 5 2 4) (5 1 8 6 3 7 2 4) (1 5 8 6 3 7 2 4) (3 6 8 1 5 7 2 4) (6 3 1 7 5 8 2 4) (7 5 3 1 6 8 2 4) (7 3 8 2 5 1 6 4) (5 3 1 7 2 8 6 4) (2 5 7 1 3 8 6 4) (3 6 2 5 8 1 7 4) (6 1 5 2 8 3 7 4) (8 3 1 6 2 5 7 4) (2 8 6 1 3 5 7 4) (5 7 2 6 3 1 8 4) (3 6 2 7 5 1 8 4) (6 2 7 1 3 5 8 4) (3 7 2 8 6 4 1 5) (6 3 7 2 4 8 1 5) (4 2 7 3 6 8 1 5) (7 1 3 8 6 4 2 5) (1 6 8 3 7 4 2 5) (3 8 4 7 1 6 2 5) (6 3 7 4 1 8 2 5) (7 4 2 8 6 1 3 5) (4 6 8 2 7 1 3 5) (2 6 1 7 4 8 3 5) (2 4 6 8 3 1 7 5) (3 6 8 2 4 1 7 5) (6 3 1 8 4 2 7 5) (8 4 1 3 6 2 7 5) (4 8 1 3 6 2 7 5) (2 6 8 3 1 4 7 5) (7 2 6 3 1 4 8 5) (3 6 2 7 1 4 8 5) (4 7 3 8 2 5 1 6) (4 8 5 3 1 7 2 6) (3 5 8 4 1 7 2 6) (4 2 8 5 7 1 3 6) (5 7 2 4 8 1 3 6) (7 4 2 5 8 1 3 6) (8 2 4 1 7 5 3 6) (7 2 4 1 8 5 3 6) (5 1 8 4 2 7 3 6) (4 1 5 8 2 7 3 6) (5 2 8 1 4 7 3 6) (3 7 2 8 5 1 4 6) (3 1 7 5 8 2 4 6) (8 2 5 3 1 7 4 6) (3 5 2 8 1 7 4 6) (3 5 7 1 4 2 8 6) (5 2 4 6 8 3 1 7) (6 3 5 8 1 4 2 7) (5 8 4 1 3 6 2 7) (4 2 5 8 6 1 3 7) (4 6 1 5 2 8 3 7) (6 3 1 8 5 2 4 7) (5 3 1 6 8 2 4 7) (4 2 8 6 1 3 5 7) (6 3 5 7 1 4 2 8) (6 4 7 1 3 5 2 8) (4 7 5 2 6 1 3 8) (5 7 2 6 3 1 4 8))</span>
<span class="p">(</span><span class="nb">length </span><span class="p">(</span><span class="nf">queens</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">;Value: 92</span>
</pre></div>
</div>
</div>


<div id="outline-container-org7f0a329" class="outline-2">
<h2 id="org7f0a329">Упражнение 2.43</h2>
<div class="outline-text-2" id="text-org7f0a329">
<p>
Процедура Луиса для queens работала медленно. Выяснилось что он поменял местами отображения в flatmap.
</p>

<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">flatmap</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">new-row</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">rest-of-queens</span><span class="p">)</span>
	  <span class="p">(</span><span class="nf">adjoin-position</span> <span class="nv">new-row</span> <span class="nv">k</span> <span class="nv">rest-of-queens</span><span class="p">))</span>
	<span class="p">(</span><span class="nf">queen-cols</span> <span class="p">(</span><span class="nb">- </span><span class="nv">k</span> <span class="mi">1</span><span class="p">))))</span>
 <span class="p">(</span><span class="nf">enumerate-interval</span> <span class="mi">1</span> <span class="nv">board-size</span><span class="p">))</span>
</pre></div>

<p>
Объясните почему смена отображения замедляет программу. Оцени время для восьми ферзей если для 6 было время T.
</p>

<p>
(queen-cols (- k 1)) вызывается 8 раз.
</p>

<p>
Замедление происходит потому что считаем 8 раз предыдущие позиции на каждом вызове рекурсии. То есть если оценивать во времени обхода этих позиций то рост будет 8<sup>N</sup> где N количество позиций. Количество позиций сложная функция из-за фильтра, но после 5 она начинает резко расти. За счет этого наблюдается замедление.
</p>

<p>
Допустим для 6 позиций заняло время T. что бы для 7 позиций посчитать она выполнит 8 раз для 6 позиций. Потом количество позиций увеличится в 8 раз. потом применим функцию фильтра, которая сократит варианты. И еще раз выполнится 8 раз для 7. То есть итоговое T, будет порядка (8<sup>2</sup>) T.
</p>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/scheme/" rel="tag">scheme</a></li>
            <li><a class="tag p-category" href="../../categories/sequences_as_conventional_interfaces/" rel="tag">sequences_as_conventional_interfaces</a></li>
            <li><a class="tag p-category" href="../../categories/sicp/" rel="tag">sicp</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../sicp-22-ierarkhicheskie-dannye-i-svoistvo-zamykaniia-the-closure-property/" rel="prev" title="SICP 2.2 Иерархические данные и свойство замыкания (the closure property).">Предыдущая запись</a>
            </li>
            <li class="next">
                <a href="../sicp-224-primer-iazyk-izobrazhenii/" rel="next" title="SICP 2.2.4 Пример: Язык изображений.">Следующая запись</a>
            </li>
        </ul></nav></aside></article></main><footer id="footer"><p>Contents © 2021         <a href="mailto:anton.s.pilipenko@gmail.com">Velikii Nehochuha</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
                <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
